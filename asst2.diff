This asst2 patch generated by /home/cs3231/bin/cs3231_generate_diff for z5059988 on Fri  4 May 13:47:37 AEST 2018
diff --unidirectional-new-file -EdbwBr -u -X /home/cs3231/assigns/asst2/src/../diffex /home/cs3231/assigns/asst2/src/design.txt /import/ravel/3/z5059988/cs3231/asst2-src/design.txt
--- design.txt	2018-03-12 22:15:08.000000000 +1100
+++ design.txt	2018-05-04 13:28:37.287661389 +1000
@@ -1 +1,141 @@
-Place your design document here.
+COMP3231 Assignment 2 Design Doc
+
+##############################
+Basic Issues in the Assignment
+##############################
+
+P. For each file that is opened, we need to maintain the current index
+into the file and where it corresponds to on the filesystem. In doing so,
+we need to preserve the semantics of fork() and dup2(), where open file
+descriptors (FDs) are replicated.
+
+S. To track the state of open files, we maintain a global open file
+(OF) table shared across processes. In each entry, we store a pointer
+to the underlying `vnode` and the current index into the file (file
+pointer/offset).
+
+P. We need to support an arbitrary number of open files on the system
+at any given time, the maximum of which is OPEN_MAX * PID_MAX.
+
+S. We cannot simply allocate an array of size OPEN_MAX * PID_MAX in
+kernel memory. We chose to store the OF table as a dynamically allocated
+array. For each new entry, we expand the OF table size by 1.
+
+P. Since we cannot simply restrict access to stdin, stdout and stderr
+to a single process, we need to maintain FDs to each stream that are
+unique to each process, but not to the entire system.
+
+S. So, for each process, we maintain an individual file descriptor (FD)
+table, inside which we store a pointer to the appropriate OF table entry.
+
+P. In addition, we need to handle opening files for different modes of
+use, particularly reading and writing.
+
+S. To do this, we store two flags in the FD table entry for the file,
+namely `can_read` and `can_write`. The per-process FD table is stored
+in the `struct proc` data structure.
+
+P. We also need to allocate file descriptors in a logical manner for
+each process. Since 0, 1 and 2 are reserved for standard streams, it
+makes sense to skip these file descriptors and begin allocation of files
+opened by the process at FD 3.
+
+S. The logical allocation of FDs is achieved by using the lowest available
+unallocated FD in the process. Since we use a fixed-size FD table, we use
+a flag to indicate which entries in the FD table are unallocated. Note
+that if stdout and/or stderr are closed at any point, 1 and 2 may be
+returned as file descriptors for other files in subsequent calls to open()
+or re-attached to the console if desired.
+
+P. Since pointers supplied from applications (user space) cannot
+inherently be trusted (e.g. they could reference kernel space), we need
+a method of differentiating between user-supplied and kernel-supplied
+pointers.
+
+S. To do this, we used the kernel methods copyin() and copyout() to move
+data between user and kernel space. If a user-specified pointer attempts
+to dereference to a restricted region of memory, these functions will
+trigger an error, which we pass to the user.
+
+P. We need to ensure that user programs that invoke our syscalls do not
+crash the system.
+
+S. Most of our error handling is implemented by the primitive VFS layer
+and vnode operations. Thus, any error codes returned by these functions
+are used directly, including I/O errors, opening non-existent files,
+writing to directories etc. The rest of the error checking is handled by
+our syscall implementation, including checking that the user-provided
+FDs are valid and warning the user of running out of memory or running
+out of space in the processesâ€™ FD table.
+
+P. We need to support the ability to change the current seek position
+of an open file with respect to a signed 64-bit offset.
+
+S. We realised that the seekability of the underlying file object
+associated to a particular file descriptor will not change. Hence, it
+made sense to cache whether the file is seekable as soon as it is opened,
+saving repeated function calls to VOP_ISSEEKABLE(). We therefore added a
+`can_seek` flag to our OF table entries. We handled passing the 64-bit
+offset to and from the user with the kernel-provided join32to64() and
+split64to32() helpers.
+
+P. When we duplicate file descriptors with dup2(), we need to ensure
+that if the FD we are copying onto refers to an open file, it is closed
+before the duplication occurs.
+
+S. We check the free property of our FD struct to verify whether it was
+previously used to refer to another open file - if it was not free then
+we close the old file.
+
+P. We need to ensure that duplicated file descriptors refer to the same
+file and share the same seek pointer.
+
+S. Since file seek pointers and vnodes to open files are maintained in
+the OF table entries, when we duplicate an FD, we simply copy over the
+pointer to the OF table entry that corresponds to the file opened. This
+ensures both the original and duplicated FDs maintain the same seek
+pointer and point to the same file.
+
+P. Our syscalls must function correctly when multiple processes are
+running concurrently. That is, we must implement the appropriate
+synchronization within the syscall implementation.
+
+S. Since we assume that our processes are single-threaded, we only need
+to consider concurrency issues at the process level. The only shared
+state between processes is the `open_file` table and the associated
+size `num_files`, for which we introduced the lock `of_lock`, acquired
+and released before accessing the `open_files` array or updating the
+`num_files` variable. In addition, each OF entry contains an `offset`
+and `refcount`, both of which require mutual exclusion since a process
+may duplicate an FD. So, we introduced a `file_lock` for each OF entry
+and acquired and released this lock whenever reading or updating the
+`offset` or `refcount`. Finally, we need to ensure that all reads,
+writes and lseeks on a file are atomic (e.g. another process may write
+to the file while another reads from it). To achieve this, we acquire
+the `of_lock` before performing the corresponding vnode operation
+(i.e. VOP_READ/VOP_WRITE/VOP_STAT).
+
+#######################
+Summary of File Changes
+#######################
+
+kern/include/syscall.h: contains prototypes for our syscalls
+
+file.h: contains definitions of the data structures used and prototypes
+for helper functions
+
+file.c: contains implementation of syscalls and helper functions
+
+kern/syscall/runprogram.c: per-process FD table is initialised here,
+along with attaching stdout and stderr to the console
+
+kern/proc/proc.c: per-process FD table is freed in proc_destroy()
+
+kern/arch/mips/syscall/syscall.c: our syscall implementation functions are
+called from here and their return values are placed in the right registers
+
+kern/main/main.c: boot() and shutdown() functions initialize and cleanup
+the OF table
+
+kern/vm/kmalloc.c: implementation of the helper function krealloc()
+is provided here
diff --unidirectional-new-file -EdbwBr -u -X /home/cs3231/assigns/asst2/src/../diffex /home/cs3231/assigns/asst2/src/kern/arch/mips/syscall/syscall.c /import/ravel/3/z5059988/cs3231/asst2-src/kern/arch/mips/syscall/syscall.c
--- kern/arch/mips/syscall/syscall.c	2018-03-12 22:15:08.000000000 +1100
+++ kern/arch/mips/syscall/syscall.c	2018-05-04 13:28:37.295661395 +1000
@@ -35,7 +35,8 @@
 #include <thread.h>
 #include <current.h>
 #include <syscall.h>
-
+#include <endian.h>
+#include <copyinout.h>
 
 /*
  * System call dispatcher.
@@ -99,6 +100,11 @@
 
 	retval = 0;
 
+	/* return values initialized by certain syscalls */
+	size_t nbytes = 0; /* number of bytes read/written */
+	int fd = 0; /* file descriptor of file being opened or duplicated */
+	off_t pos; /* new file pointer position */
+
 	switch (callno) {
 	    case SYS_reboot:
 		err = sys_reboot(tf->tf_a0);
@@ -108,9 +113,31 @@
 		err = sys___time((userptr_t)tf->tf_a0,
 				 (userptr_t)tf->tf_a1);
 		break;
-
-	    /* Add stuff here */
-
+	case SYS_open:
+		err = sys_open((const_userptr_t) tf->tf_a0,
+			(uint32_t) tf->tf_a1, (mode_t) tf->tf_a2, &fd);
+		break;
+	case SYS_close:
+		err = sys_close((uint32_t) tf->tf_a0);
+		break;
+	case SYS_read:
+		err = sys_read((uint32_t) tf->tf_a0, (const_userptr_t) tf->tf_a1,
+			(uint32_t) tf->tf_a2, &nbytes);
+		break;
+	case SYS_write:
+		err = sys_write((uint32_t) tf->tf_a0, (const_userptr_t) tf->tf_a1,
+			(uint32_t) tf->tf_a2, &nbytes);
+		break;
+	case SYS_lseek: ;
+		int64_t offset;
+		int whence;
+		join32to64(tf->tf_a2, tf->tf_a3, (uint64_t *) &offset);
+		copyin((userptr_t)tf->tf_sp + 16, &whence, sizeof(int));
+		err = sys_lseek((uint32_t) tf->tf_a0, offset, whence, &pos);
+		break;
+	case SYS_dup2:
+		err = sys_dup2((int32_t) tf->tf_a0, (int32_t) tf->tf_a1, &fd);
+		break;
 	    default:
 		kprintf("Unknown syscall %d\n", callno);
 		err = ENOSYS;
@@ -126,10 +152,17 @@
 		 */
 		tf->tf_v0 = err;
 		tf->tf_a3 = 1;      /* signal an error */
-	}
-	else {
+	} else {
 		/* Success. */
+		if (callno == SYS_open || callno == SYS_dup2) {
+			tf->tf_v0 = fd;
+		} else if (callno == SYS_read || callno == SYS_write) {
+			tf->tf_v0 = nbytes;
+		} else if (callno == SYS_lseek) {
+			split64to32(pos, &tf->tf_v0, &tf->tf_v1);
+		} else {
 		tf->tf_v0 = retval;
+		}
 		tf->tf_a3 = 0;      /* signal no error */
 	}
 
Only in /home/cs3231/assigns/asst2/src/kern/compile: .keep_me
diff --unidirectional-new-file -EdbwBr -u -X /home/cs3231/assigns/asst2/src/../diffex /home/cs3231/assigns/asst2/src/kern/include/file.h /import/ravel/3/z5059988/cs3231/asst2-src/kern/include/file.h
--- kern/include/file.h	2018-03-12 22:15:08.000000000 +1100
+++ kern/include/file.h	2018-05-04 13:28:37.295661395 +1000
@@ -5,16 +5,37 @@
 #ifndef _FILE_H_
 #define _FILE_H_
 
-/*
- * Contains some file-related maximum length constants
- */
+/* contains some file-related maximum length constants */
 #include <limits.h>
 
+/* contains synchronization primitives */
+#include <synch.h>
 
-/*
- * Put your function declarations and data types here ...
- */
+/* state relating to an open file on the system */
+typedef struct OF {
+	struct vnode *v; /* ptr to the underlying vnode */
+	off_t offset; /* current index into the file, i.e. the file pointer */
+	bool can_seek; /* true if the related file object can be lseek'd */
+	uint32_t refcount; /* reference count for the OF entry */
+	struct lock *file_lock; /* mutex for offset & refcount */
+} OF;
 
+/* state relating to a file descriptor in a process */
+typedef struct FD {
+	bool free; /* used to mark this fd as available */
+	OF *file; /* ptr to the open file entry associated with this fd */
+	bool can_read; /* used to handle O_RDONLY open mode */
+	bool can_write; /* used to handle O_WRONLY open mode */
+} FD;
+
+extern struct OF **open_files; /* dynamically allocated open file table */
+uint32_t num_files; /* number of open files on the system */
+struct lock *of_lock; /* mutex for open file table & num_files */
 
+/* function prototypes for helpers */
+bool valid_fd(uint32_t fd);
+void fs_bootstrap(void);
+void fs_clear_tables(void);
+int init_fd_table(void);
 
 #endif /* _FILE_H_ */
diff --unidirectional-new-file -EdbwBr -u -X /home/cs3231/assigns/asst2/src/../diffex /home/cs3231/assigns/asst2/src/kern/include/lib.h /import/ravel/3/z5059988/cs3231/asst2-src/kern/include/lib.h
--- kern/include/lib.h	2018-03-12 22:15:08.000000000 +1100
+++ kern/include/lib.h	2018-04-24 23:32:40.000000000 +1000
@@ -128,6 +128,7 @@
  */
 void *kmalloc(size_t size);
 void kfree(void *ptr);
+void *krealloc(void *src, uint32_t size, uint32_t new_size);
 void kheap_printstats(void);
 void kheap_nextgeneration(void);
 void kheap_dump(void);
diff --unidirectional-new-file -EdbwBr -u -X /home/cs3231/assigns/asst2/src/../diffex /home/cs3231/assigns/asst2/src/kern/include/proc.h /import/ravel/3/z5059988/cs3231/asst2-src/kern/include/proc.h
--- kern/include/proc.h	2018-03-12 22:15:08.000000000 +1100
+++ kern/include/proc.h	2018-04-28 19:00:39.151857575 +1000
@@ -35,9 +35,10 @@
  *
  * Note: curproc is defined by <current.h>.
  */
-
+#include <limits.h>
 #include <spinlock.h>
 
+struct FD;
 struct addrspace;
 struct thread;
 struct vnode;
@@ -71,6 +72,7 @@
 	struct vnode *p_cwd;		/* current working directory */
 
 	/* add more material here as needed */
+	struct FD **fds; /* pointer to this process' file descriptor table */
 };
 
 /* This is the process structure for the kernel and for kernel-only threads. */
diff --unidirectional-new-file -EdbwBr -u -X /home/cs3231/assigns/asst2/src/../diffex /home/cs3231/assigns/asst2/src/kern/include/syscall.h /import/ravel/3/z5059988/cs3231/asst2-src/kern/include/syscall.h
--- kern/include/syscall.h	2018-03-12 22:15:08.000000000 +1100
+++ kern/include/syscall.h	2018-05-04 13:28:37.295661395 +1000
@@ -58,5 +56,11 @@
 
 int sys_reboot(int code);
 int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
+int sys_open(const_userptr_t path, uint32_t flags, mode_t mode, int *fd);
+int sys_close(uint32_t fd);
+int sys_read(uint32_t fd, const_userptr_t buf, size_t buflen, size_t *read);
+int sys_write(uint32_t fd, const_userptr_t buf, size_t nbytes, size_t *written);
+int sys_lseek(uint32_t fd, off_t pos, int whence, off_t *ret);
+int sys_dup2(int32_t oldfd, int32_t newfd, int *retfd);
 
 #endif /* _SYSCALL_H_ */
diff --unidirectional-new-file -EdbwBr -u -X /home/cs3231/assigns/asst2/src/../diffex /home/cs3231/assigns/asst2/src/kern/main/main.c /import/ravel/3/z5059988/cs3231/asst2-src/kern/main/main.c
--- kern/main/main.c	2018-03-12 22:15:08.000000000 +1100
+++ kern/main/main.c	2018-05-04 13:28:37.299661399 +1000
@@ -64,6 +64,9 @@
 extern const int buildversion;
 extern const char buildconfig[];
 
+extern void fs_bootstrap();
+extern void fs_clear_tables();
+
 /*
  * Copyright message for the OS/161 base code.
  */
@@ -102,7 +105,7 @@
 	kprintf("%s", harvard_copyright);
 	kprintf("\n");
 
-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n",
+	kprintf("osprj175's system version %s (%s #%d)\n",
 		GROUP_VERSION, buildconfig, buildversion);
 	kprintf("\n");
 
@@ -112,6 +115,7 @@
 	thread_bootstrap();
 	hardclock_bootstrap();
 	vfs_bootstrap();
+	fs_bootstrap();
 	kheap_nextgeneration();
 
 	/* Probe and initialize devices. Interrupts should come on. */
@@ -151,6 +155,7 @@
 
 	kprintf("Shutting down.\n");
 
+	fs_clear_tables();
 	vfs_clearbootfs();
 	vfs_clearcurdir();
 	vfs_unmountall();
diff --unidirectional-new-file -EdbwBr -u -X /home/cs3231/assigns/asst2/src/../diffex /home/cs3231/assigns/asst2/src/kern/proc/proc.c /import/ravel/3/z5059988/cs3231/asst2-src/kern/proc/proc.c
--- kern/proc/proc.c	2018-03-12 22:15:08.000000000 +1100
+++ kern/proc/proc.c	2018-05-01 23:10:00.384049158 +1000
@@ -170,6 +170,12 @@
 
 	kfree(proc->p_name);
 	kfree(proc);
+
+	/* free the per-process fd table */
+	for (int i = 0; i < OPEN_MAX; ++i) {
+		kfree(proc->fds[i]);
+	}
+	kfree(proc->fds);
 }
 
 /*
diff --unidirectional-new-file -EdbwBr -u -X /home/cs3231/assigns/asst2/src/../diffex /home/cs3231/assigns/asst2/src/kern/syscall/file.c /import/ravel/3/z5059988/cs3231/asst2-src/kern/syscall/file.c
--- kern/syscall/file.c	2018-03-12 22:15:08.000000000 +1100
+++ kern/syscall/file.c	2018-05-04 13:28:37.299661399 +1000
@@ -14,8 +14,312 @@
 #include <file.h>
 #include <syscall.h>
 #include <copyinout.h>
+#include <proc.h>
+#include <synch.h>
+
+struct OF **open_files = NULL;
 
 /*
- * Add your file-related functions here ...
+ * Initialize state required for the open file and file descriptor tables.
+ * Called from boot(), so no synchronization is required.
+ */
+void fs_bootstrap() {
+	num_files = 0;
+	open_files = NULL;
+	of_lock = lock_create("open file table lock");
+	if (of_lock == NULL) panic("Out of memory\n");
+}
+
+/*
+ * Free memory used by the open file and file descriptor tables.
+ * Called from shutdown(), so no synchronization is required.
+ */
+void fs_clear_tables() {
+	for (uint32_t i = 0; i < num_files; i++) {
+		if (open_files[i]->file_lock != NULL) {
+			lock_destroy(open_files[i]->file_lock);
+			vfs_close(open_files[i]->v);
+		}
+		kfree(open_files[i]);
+	}
+	kfree(open_files);
+	lock_destroy(of_lock);
+}
+
+/*
+ * Check if the fd is valid for the current process.
+ */
+bool valid_fd(uint32_t fd) {
+	if (fd <= 0 || fd >= OPEN_MAX) {
+		return false; /* invalid file descriptor */
+	} else if (curproc->fds[fd]->free == true) {
+		return false; /* file must not be not open */
+	}
+	return true; /* this is an allocated fd for this process */
+}
+
+/*
+ * Initialise the fd table for the process.
+ */
+int init_fd_table() {
+	struct FD **fds = kmalloc(sizeof(struct FD *) * OPEN_MAX);
+	if (fds == NULL) return ENOMEM;
+	curproc->fds = fds;
+	for (int i = 0 ; i < OPEN_MAX; ++i) {
+		curproc->fds[i] = kmalloc(sizeof(FD));
+		if (curproc->fds[i] == NULL) return ENOMEM;
+		curproc->fds[i]->free = true;
+	}
+	curproc->fds[0]->free = false; /* skip stdin fd, so stdout/err will
+	be opened on fd 1 and 2 respectively */
+	return 0;
+}
+
+/*
+ * Open a file in the specified mode. Return a process-unique file
+ * descriptor on success; otherwise, return an appropriate errno.
+ */
+int sys_open(const_userptr_t path, uint32_t flags, mode_t mode, int *fd) {
+	/* copy user space pointer to kernel space buffer */
+	char path_kern[PATH_MAX];
+	size_t path_kern_size = 0;
+	int ret = copyinstr(path, path_kern, (size_t) PATH_MAX, &path_kern_size);
+	if (ret) return ret; /* rest of error-checking handled here */
+	struct FD **fds = curproc->fds;
+
+	/* look for the first available fd */
+	int fd_found = -1;
+	for (int i = 0; i < OPEN_MAX; i++) {
+		if (fds[i]->free) {
+			fd_found = i;
+			break;
+		}
+	}
+	if (fd_found == -1) return EMFILE; /* reached max open files for this process */
+
+	/* set can_read/can_write flags according to flags argument */
+	fds[fd_found]->can_read = true;
+	fds[fd_found]->can_write = true;
+	if ((flags & O_RDWR) != 0) {
+	} else if ((flags & O_WRONLY) != 0) {
+		fds[fd_found]->can_read = false;
+	} else if (flags == O_RDONLY) {
+		fds[fd_found]->can_write = false;
+	} else {
+		return EINVAL; /* unknown flags */
+	}
+
+	/* open the file - will increase the ref count in vnode */
+	struct vnode vn;
+	struct vnode *v = &vn;
+	ret = vfs_open(path_kern, flags, mode, &v);
+	if (ret) return ret; /* rest of error-checking handled here */
+
+	/* create a new entry in open file table for the vnode */
+	lock_acquire(of_lock);
+	open_files = (struct OF **) krealloc(open_files,
+		sizeof(OF *) * num_files, sizeof(OF *) * (num_files + 1));
+	open_files[num_files] = kmalloc(sizeof(struct OF));
+	open_files[num_files]->offset = 0;
+	open_files[num_files]->refcount = 1;
+	open_files[num_files]->v = v;
+	open_files[num_files]->can_seek = VOP_ISSEEKABLE(v);
+	open_files[num_files]->file_lock = lock_create("file lock");
+	if (open_files[num_files]->file_lock == NULL) {
+		lock_release(of_lock);
+		return ENOMEM;
+	}
+	fds[fd_found]->file = open_files[num_files++];
+	lock_release(of_lock);
+
+	/* adjust file pointer in the case of O_APPEND being specified */
+	if ((flags & O_APPEND) != 0) {
+		struct stat stats;
+		VOP_STAT(fds[fd_found]->file->v, &stats);
+		fds[fd_found]->file->offset = stats.st_size; /* new entry; no sync needed */
+	}
+
+	fds[fd_found]->free = false; /* mark this fd as used */
+	*fd = fd_found;
+	return 0;
+}
+
+/*
+ * Close an open file. Return EBADF for an invalid fd.
+ */
+int sys_close(uint32_t fd) {
+	struct FD **fds = curproc->fds;
+	if (!valid_fd(fd)) return EBADF;
+
+	/* decrement OF refcount - only close file if no more references to the file */
+	lock_acquire(fds[fd]->file->file_lock);
+	if (--fds[fd]->file->refcount == 0) {
+		lock_release(fds[fd]->file->file_lock);
+
+		/* hard i/o error is unlikely and rarely checked - see kern/vfs/vfspath.c */
+		vfs_close(fds[fd]->file->v);
+
+		lock_destroy(fds[fd]->file->file_lock);
+		kfree(fds[fd]->file);
+
+		/* prevent fs_clear_tables from calling vfs_open and lock_destroy again */
+		fds[fd]->file->file_lock = NULL;
+	} else {
+		lock_release(fds[fd]->file->file_lock);
+	}
+
+	fds[fd]->free = true; /* fd can be re-used for this process */
+	return 0;
+}
+
+/*
+ * Read up to buflen bytes into the buffer buf and return number of bytes read.
  */
+int sys_read(uint32_t fd, const_userptr_t buf, size_t buflen, size_t *read) {
+	struct FD **fds = curproc->fds;
+	if (!valid_fd(fd)) {
+		return EBADF;
+	} else if (!fds[fd]->can_read) {
+		return EBADF; /* file was not opened for reading */
+	}
+
+	struct iovec iov;
+	struct vnode *v = fds[fd]->file->v;
+	struct uio u;
+
+	char buf_kern[PATH_MAX] = {0};
+	lock_acquire(fds[fd]->file->file_lock);
+	uio_kinit(&iov, &u, buf_kern, buflen, fds[fd]->file->offset, UIO_READ);
+	lock_release(fds[fd]->file->file_lock);
+
+	size_t resid = u.uio_resid;
+	lock_acquire(of_lock); /* ensure reads are atomic */
+	int ret = VOP_READ(v, &u); /* read vnode contents into buf_kern */
+	lock_release(of_lock);
+	if (ret) return ret; /* rest of error-checking handled here */
+
+	/* copy data from kernel buffer into user buffer */
+	if (resid - u.uio_resid > 0) {
+		ret = copyout(buf_kern, (userptr_t) buf, resid - u.uio_resid);
+		if (ret) return ret; /* rest of error-checking handled here */
+	}
+
+	/* advance the file offset */
+	lock_acquire(fds[fd]->file->file_lock);
+	fds[fd]->file->offset += resid - u.uio_resid;
+	lock_release(fds[fd]->file->file_lock);
+
+	*read = resid - u.uio_resid;
+	return 0;
+}
+
+/*
+ * Write up to nbytes bytes to a file and return number of bytes written.
+ */
+int sys_write(uint32_t fd, const_userptr_t buf, size_t nbytes, size_t *written) {
+	/* copy user space pointer to kernel space buffer */
+	char buf_kern[PATH_MAX] = {0};
+	if (nbytes > 0) {
+		int ret = copyin(buf, buf_kern, nbytes);
+		if (ret) return ret; /* rest of error-checking handled here */
+	}
+
+	struct FD **fds = curproc->fds;
+	if (!valid_fd(fd)) {
+		return EBADF;
+	} else if (!fds[fd]->can_write) {
+		return EBADF; /* file was not opened for writing */
+	}
+
+	struct iovec iov;
+	iov.iov_kbase = buf_kern;
+	iov.iov_len = nbytes;
+
+	struct vnode *v = fds[fd]->file->v;
+	struct uio u;
+	lock_acquire(fds[fd]->file->file_lock);
+	uio_kinit(&iov, &u, buf_kern, nbytes, fds[fd]->file->offset, UIO_WRITE);
+	lock_release(fds[fd]->file->file_lock);
+
+	size_t resid = u.uio_resid;
+	lock_acquire(of_lock); /* ensure writes are atomic */
+	int ret = VOP_WRITE(v, &u);
+	lock_release(of_lock);
+	if (ret) return ret; /* rest of error-checking handled here */
 
+	/* advance the file offset */
+	lock_acquire(fds[fd]->file->file_lock);
+	fds[fd]->file->offset += resid - u.uio_resid;
+	lock_release(fds[fd]->file->file_lock);
+
+	*written = resid - u.uio_resid;
+	return 0;
+}
+
+/*
+ * Change the file pointer offset of an open file.
+ */
+int sys_lseek(uint32_t fd, off_t pos, int whence, off_t *ret) {
+	struct FD **fds = curproc->fds;
+	if (!valid_fd(fd)) return EBADF;
+
+	/* only proceed if underlying file object is seekable */
+	if (!fds[fd]->file->can_seek) {
+		return ESPIPE;
+	}
+
+	lock_acquire(fds[fd]->file->file_lock);
+	off_t old_offset = fds[fd]->file->offset;
+	if (whence == SEEK_SET) {
+		fds[fd]->file->offset = pos;
+	} else if (whence == SEEK_CUR) {
+		fds[fd]->file->offset += pos;
+	} else if (whence == SEEK_END) {
+		struct stat stats;
+		lock_acquire(of_lock); /* another process may change file size */
+		VOP_STAT(fds[fd]->file->v, &stats);
+		lock_release(of_lock);
+		fds[fd]->file->offset = stats.st_size + pos;
+	} else {
+		lock_release(fds[fd]->file->file_lock);
+		return EINVAL; /* unknown whence */
+	}
+
+	/* revert to old offset if new offset < 0 */
+	if (fds[fd]->file->offset < 0) {
+		fds[fd]->file->offset = old_offset;
+		lock_release(fds[fd]->file->file_lock);
+		return EINVAL;
+	}
+
+	*ret = fds[fd]->file->offset;
+	lock_release(fds[fd]->file->file_lock);
+	return 0;
+}
+
+/*
+ * Clone file handles.
+ */
+int sys_dup2(int32_t oldfd, int32_t newfd, int32_t *retfd) {
+	if (!valid_fd(oldfd) || newfd < 0 || newfd >= OPEN_MAX) return EBADF;
+
+	/* do nothing if both FDs are identical */
+	if (oldfd != newfd) {
+		struct FD **fds = curproc->fds;
+
+		/* newfd refers to an already open file descriptor - close it */
+		if (!fds[newfd]->free) sys_close(newfd);
+
+		/* clone properties of oldfd onto newfd and increment refcount */
+		lock_acquire(fds[oldfd]->file->file_lock);
+		fds[oldfd]->file->refcount++;
+		lock_release(fds[oldfd]->file->file_lock);
+		fds[newfd]->file = fds[oldfd]->file;
+		fds[newfd]->free = false;
+		fds[newfd]->can_read = fds[oldfd]->can_read;
+		fds[newfd]->can_write = fds[oldfd]->can_write;
+	}
+
+	*retfd = newfd;
+	return 0;
+}
diff --unidirectional-new-file -EdbwBr -u -X /home/cs3231/assigns/asst2/src/../diffex /home/cs3231/assigns/asst2/src/kern/syscall/runprogram.c /import/ravel/3/z5059988/cs3231/asst2-src/kern/syscall/runprogram.c
--- kern/syscall/runprogram.c	2018-03-12 22:15:08.000000000 +1100
+++ kern/syscall/runprogram.c	2018-05-04 13:28:37.303661402 +1000
@@ -44,6 +44,11 @@
 #include <vfs.h>
 #include <syscall.h>
 #include <test.h>
+#include <file.h>
+#include <vnode.h>
+#include <proc.h>
+
+extern struct OF **open_files;
 
 /*
  * Load program "progname" and start running it in usermode.
@@ -97,6 +102,58 @@
 		return result;
 	}
 
+	/* initialise state for the proc's fd table */
+	result = init_fd_table();
+	if (result) return result;
+
+	/* open stdout/err and connect to console device */
+	struct vnode *v1;
+	struct vnode *v2;
+	mode_t m = 0;
+	char c1[] = "con:";
+	char c2[] = "con:";
+	result = vfs_open(c1, O_WRONLY, m, &v1);
+	if (result) return result;
+	result = vfs_open(c2, O_WRONLY, m, &v2);
+	if (result) return result;
+	struct OF *file1 = kmalloc(sizeof(struct OF));
+	if (file1 == NULL) return ENOMEM;
+	struct OF *file2 = kmalloc(sizeof(struct OF));
+	if (file2 == NULL) return ENOMEM;
+	file1->offset = 0;
+	file2->offset = 0;
+	file1->refcount = 1;
+	file2->refcount = 1;
+	file1->v = v1;
+	file2->v = v2;
+	file1->can_seek = VOP_ISSEEKABLE(v1);
+	file2->can_seek = VOP_ISSEEKABLE(v2);
+	file1->file_lock = lock_create("file lock");
+	if (file1->file_lock == NULL) return ENOMEM;
+	file2->file_lock = lock_create("file lock");
+	if (file2->file_lock == NULL) return ENOMEM;
+
+	/* add files to global open_files table accounting for multiple processes */
+	lock_acquire(of_lock);
+	open_files = (struct OF **) krealloc(open_files,
+		sizeof(OF *) * num_files, sizeof(OF *) * (num_files + 2));
+	if (open_files == NULL) {
+		lock_release(of_lock);
+		return ENOMEM;
+	}
+	open_files[num_files++] = file1;
+	open_files[num_files++] = file2;
+	lock_release(of_lock);
+
+	curproc->fds[1]->free = false; /* skip stdin on fd 0 */
+	curproc->fds[2]->free = false;
+	curproc->fds[1]->can_write = true;
+	curproc->fds[2]->can_write = true;
+	curproc->fds[1]->can_read = false;
+	curproc->fds[2]->can_read = false;
+	curproc->fds[1]->file = file1;
+	curproc->fds[2]->file = file2;
+
 	/* Warp to user mode. */
 	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
 			  NULL /*userspace addr of environment*/,
diff --unidirectional-new-file -EdbwBr -u -X /home/cs3231/assigns/asst2/src/../diffex /home/cs3231/assigns/asst2/src/kern/vm/kmalloc.c /import/ravel/3/z5059988/cs3231/asst2-src/kern/vm/kmalloc.c
--- kern/vm/kmalloc.c	2018-03-12 22:15:08.000000000 +1100
+++ kern/vm/kmalloc.c	2018-04-24 23:32:40.000000000 +1000
@@ -1222,3 +1222,13 @@
 	}
 }
 
+/*
+ * Increase size of a buffer (crude version of krealloc).
+ */
+void *krealloc(void *src, uint32_t size, uint32_t new_size) {
+	void *tmp = kmalloc(new_size);
+	KASSERT(tmp != NULL);
+	memcpy(tmp, src, size);
+	kfree(src);
+	return tmp;
+}
