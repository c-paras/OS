1.
The counter variable is a shared resource between the threads of execution.
As each of these threads require updating the counter, without the use
of synchronisation the operating system could for example interleave the
instructions such that `counter = counter + 1` is executed in multiple
threads before the instruction `b = counter` is executed, leaving an unexpected
value in b.

To prevent concurrent (unsafe) modification of the counter variable, we employed
the use of a lock to achieve mutual exclusion (made available through the OS/161
locking primitives). We identified the critical section in adder() beginning
from the assignment `a = counter` and ending at the end of the if/else block.
Accordingly, we acquire the lock prior to entry of the critical region and release
the lock after execution of the critical region has finished. Since our lock
needed to be used in every adder() thread, our lock was created in the maths()
function and destroyed after all the adder() threads terminated.

2.
In the original code, bill() and ben() are called in separate threads
and acquire the same two locks in the reverse order. This causes a deadlock
for example, when the following interleaving occurs:

bill's thread          | ben's thread
1: lock_acquire(locka) |
2:                     | lock_acquire(lockb)
3: lock_acquire(lockb) |
4:                     | lock_acquire(locka)

This occurs since bill's thread is waiting for lockb to be released (which ben
currently has), and ben's thread is waiting for locka to be released (which bill
currently has). As each thread is waiting for the other to release a requested
resource, a deadlock occurs.

We used the prevention strategy to deal with the deadlock, removing the circular wait
condition by ordering the resource requests such that the threads acquire the locks in
the same order. This solution ensures that the first lock is required to be held by a
thread before the second lock can be acquired. As such, neither thread can acquire a
lock that the other thread will need if the other thread has already acquired one of
its locks.

With this request ordering, there are four possible interleavings of requests:

Case 1: One of the threads requests (and acquires) both locks before the other thread. When
the other thread requests locka, it blocks until the first thread releases locka. Since the
first thread has access to all the resources it requires, it will eventually complete and
release its resources for the other thread to use.

bill's thread          | ben's thread          || bill's thread          | ben's thread
1: lock_acquire(locka) |                       || 1:                     | lock_acquire(locka)
2: lock_acquire(lockb) |                       || 2:                     | lock_acquire(lockb)
3:                     | lock_acquire(lock_a)  || 3: lock_acquire(locka) |
4:                     | lock_acquire(lock_b)  || 4: lock_acquire(lockb) |

Case 2: One of the threads requests (and acquires) locka, then the other thread requests locka
and blocks (as the first thread is holding it). The first thread proceeds to acquire lockb.
Again, the first thread has access to all the resources it requires, so it will eventually
complete and release its resources for the other thread to use.

bill's thread          | ben's thread          || bill's thread          | ben's thread
1: lock_acquire(locka) |                       || 1:                     | lock_acquire(locka)
2:                     | lock_acquire(lock_a)  || 2: lock_acquire(locka) |
3: lock_acquire(lockb) |                       || 3:                     | lock_acquire(lockb)
4:                     | lock_acquire(lock_b)  || 4: lock_acquire(lockb) |

3.
- The buffer used by the producer and consumer consists of a fixed-size array and two
  indexes, `head` (referring to the first item for consumption) and `tail` (referring
  to the next available slot for production).
- We used a lock (buffer_lock) to restrict access to the buffer (a shared resource
  between producer/consumer threads). Any time that the buffer is modified (producer
  produces an item or consumer consumes an item), the lock is used to ensure
  mutual exclusion.
- We used two condition variables:
  - has_capacity; to track whether the buffer has at least one free slot
  - has_data: to track whether the buffer has at least one item available to consume
- Consumer waits on has_data, sleeping if there are no items available to consume.
  Signals has_capacity once it finishes consuming an item by adjusting the head pointer.
- Producer waits on has_capacity, sleeping if there is no space in the buffer to
  produce items. Signals has_data once it finishes producing an item by adding it to the
  end of the queue and adjusting the tail pointer.
- An alternative solution is to use semaphores in place of condition variables.
  However, for the sake of code clarity, it was decided to use condition variables.
