1.
The counter variable is a shared resource between the threads of execution.
As each of these threads require updating the counter, without the use
of synchronisation the operating system could for example interleave the
instructions such that `counter = counter + 1` is executed in multiple
threads before the instruction `b = counter` is executed, leaving an unexpected
value in b.

To prevent concurrent (unsafe) modification of the counter variable, we employed
the use of a lock to achieve mutual exclusion (made available through the OS/161
locking primitives).  We identified the critical section in adder() beginning
from the assignment `a = counter` and ending at the end of the if/else block.
Accordingly, we acquire the lock prior to entry of the critical region and release
the lock after execution of the critical region has finished. Since our lock
needed to be used in every adder() thread, our lock was created in the maths()
function and destroyed after all the adder() threads terminated.

2.
In the original code, bill() and ben() are called in seperate threads
and acquire the same two locks in the reverse order. This causes a deadlock
for example, when the following interleaving occurs:

bill's thread          | ben's thread
1: lock_acquire(locka) |
2:                     | lock_acquire(lockb)
3: lock_acquire(lockb) |
4:                     | lock_acquire(locka)

A deadlock occurs since bill's thread waits for a lock on b
which ben currently has and ben's thread waits for a lock on a, which
bill currently has.

To prevent the deadlock, we ensured that the threads acquire the locks
in the same order. This solution works since neither thread can acquire a
lock that the other thread will need if the second thread has already
acquired one of its locks.

3.

