1.
The counter variable is a shared resource between the threads of execution.
As each of these threads require updating the counter, without the use
of synchronisation the operating system could for example interleave the
instructions such that `counter = counter + 1` is executed in multiple
threads before the instruction `b = counter` is executed, leaving an unexpected
value in b.

To prevent concurrent (unsafe) modification of the counter variable, we employed
the use of a lock to achieve mutual exclusion (made available through the OS/161
locking primitives).  We identified the critical section in adder() beginning
from the assignment `a = counter` and ending at the end of the if/else block.
Accordingly, we acquire the lock prior to entry of the critical region and release
the lock after execution of the critical region has finished. Since our lock
needed to be used in every adder() thread, our lock was created in the maths()
function and destroyed after all the adder() threads terminated.

2.
In the original code, bill() and ben() are called in separate threads
and acquire the same two locks in the reverse order. This causes a deadlock
for example, when the following interleaving occurs:

bill's thread          | ben's thread
1: lock_acquire(locka) |
2:                     | lock_acquire(lockb)
3: lock_acquire(lockb) |
4:                     | lock_acquire(locka)

This occurs since bill's thread is waiting for lockb to be released (which ben
currently has), and ben's thread is waiting for locka to be released (which bill
currently has). As each thread is waiting for the other to release a requested
resource, a deadlock occurs.

To prevent the deadlock, we ensured that the threads acquire the locks
in the same order. This solution ensures that the first lock is required to be
held by a thread before the second lock can be acquired. As such, neither thread
thread can acquire a lock that the other thread will need if the other thread
has already acquired one of its locks.

3.

