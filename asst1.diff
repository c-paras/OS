This asst1 patch generated by /import/adams/1/cs3231/bin/cs3231_generate_diff for z5059988 on Sat 31 Mar 13:58:03 AEDT 2018
diff --unidirectional-new-file -EdbwBr -u -X /home/cs3231/assigns/asst1/src/../diffex /home/cs3231/assigns/asst1/src/design.txt /import/ravel/3/z5059988/cs3231/asst1-src/design.txt
--- design.txt	2018-03-09 13:16:22.000000000 +1100
+++ design.txt	2018-03-31 13:43:57.000000000 +1100
@@ -1 +1,176 @@
-Place your design document here.
+######################################
+Part 1: Concurrent Mathematics Problem
+######################################
+
+The counter variable is a shared resource between the threads of execution.
+Since all these threads update the counter, without the use of
+synchronisation, the OS could for example interleave the instructions such
+that `counter = counter + 1` is executed in multiple threads before
+`b = counter` is executed, leaving an unexpected value in `b`.
+
+To prevent concurrent/unsafe modification of the counter variable, we employed
+the use of a lock to achieve mutual exclusion. We identified the critical
+section in adder() beginning from the assignment `a = counter` and ending at
+the end of the if/else block. Accordingly, we acquire the lock prior to
+entering the critical region and release the lock after the critical region
+has finished executing. Since our lock is used in every adder() thread, we
+create the lock in the maths() function and destroy it after all the adder()
+threads terminated.
+
+#######################
+Part 2: Simple Deadlock
+#######################
+
+In the original code, bill() and ben() are called in separate threads
+and acquire the same two locks in the reverse order. This causes a deadlock
+for example, when the following interleaving occurs:
+
+bill's thread          | ben's thread
+1: lock_acquire(locka) |
+2:                     | lock_acquire(lockb)
+3: lock_acquire(lockb) |
+4:                     | lock_acquire(locka)
+
+This occurs since bill's thread is waiting for lockb to be released (which ben
+currently has) and ben's thread is waiting for locka to be released (which bill
+currently has). As each thread is waiting for the other to release a requested
+resource, a deadlock occurs.
+
+We used the prevention strategy to deal with the deadlock, removing the circular
+wait condition by ordering the resource requests such that the threads acquire
+the locks in the same order. This solution ensures that the first lock is
+required to be held by a thread before the second lock can be acquired. As such,
+neither thread can acquire a lock that the other thread will need if the other
+thread has already acquired one of its locks.
+
+With this request ordering, there are four possible interleavings of requests
+(none of which result in deadlock):
+
+Case 1: One of the threads acquires both locks before the other thread. When
+the other thread requests locka, it blocks until the first thread releases it.
+Since the first thread has access to all the resources it requires, it will
+eventually complete and release its resources for the other thread to use.
+
+bill's thread          | ben's thread
+1: lock_acquire(locka) |
+2: lock_acquire(lockb) |
+3:                     | lock_acquire(locka)
+4:                     | lock_acquire(lockb)
+
+OR
+
+bill's thread          | ben's thread
+1:                     | lock_acquire(locka)
+2:                     | lock_acquire(lockb)
+3: lock_acquire(locka) |
+4: lock_acquire(lockb) |
+
+Case 2: One of the threads acquires locka, then the other thread requests
+locka and blocks. The first thread proceeds to acquire lockb. Again, the first
+thread has access to all the resources it requires, so it will eventually
+complete and release its resources for the other thread to use.
+
+bill's thread          | ben's thread
+1: lock_acquire(locka) |
+2:                     | lock_acquire(locka)
+3: lock_acquire(lockb) |
+4:                     | lock_acquire(lockb)
+
+OR
+
+bill's thread          | ben's thread
+1:                     | lock_acquire(locka)
+2: lock_acquire(locka) |
+3:                     | lock_acquire(lockb)
+4: lock_acquire(lockb) |
+
+################################################
+Part 3: Bounded Buffer Producer/Consumer Problem
+################################################
+
+- The circular buffer used by the producer and consumer consists of a fixed-size
+  array and two indexes, `head` (referring to the first item for consumption)
+  and `tail` (referring to the next available slot for production).
+- We used a lock (buffer_lock) to restrict access to the buffer (a shared
+  resource between producer/consumer threads). Any time that the buffer is
+  modified (producer produces an item or consumer consumes an item), the lock is
+  used to ensure mutual exclusion.
+- We used two condition variables:
+  - `has_capacity`: to track whether the buffer has at least one free slot
+  - `has_data`: to track whether the buffer has at least one item available for
+    consumption
+- Consumer:
+  - waits on `has_data`, sleeping if there are no items available to consume
+  - signals `has_capacity` after it finishes consuming item by adjusting `head`
+- Producer:
+  - waits on `has_capacity`, sleeping if there is no space in the buffer to
+    produce items
+  - signals `has_data` once it finishes producing an item by adding it to the
+    end of the queue and adjusting `tail`
+- Before either thread blocks while waiting for data or space, we check the
+  number of items in the queue. This is done in a loop so that when the thread
+  unblocks, the condition is checked again to ensure there is still data or
+  space. The member `buffer.num_items` is used instead of relying on the `head`
+  and `tail` values in order to correctly distinguish between the empty and
+  full cases.
+- An alternative solution is to use semaphores in place of condition variables.
+  However, for the sake of code clarity, we decided to use condition variables.
+
+###########################
+Part 4: Bar Synchronisation
+###########################
+
+At a high-level, this problem is essentially a more involved producer-consumer
+scenario in which the producers are customers who order drinks ("producing"
+orders) and the consumers are bartenders, who serve the customers ("consuming"
+the orders). Concurrency issues arise from the use of shared resources (bottles)
+and managing the queue of orders to ensure all customers are served the correct
+drinks.
+
+Once a drink is ordered by a customer, a condition variable (`order_made`) is
+signalled in order_drink() to wake up a bartender, who waits for the signal in
+take_order(). The newly created order is added to a global queue of orders
+named `pending_orders`. Since multiple threads require access to the queue,
+we require mutual exclusion to prevent race conditions (e.g. an order being
+served by multiple bartenders). This is achieved through the use of a lock
+`que_lock`, acquired and released before and after enqueuing and dequeuing.
+
+To prevent bartender and customer threads from busy waiting, we added a
+semaphore to the `barorder` struct so that P() and V() could be executed
+from any function with access to the order. In order_drink(), we create the
+semaphore and decrement it using P(), which blocks the customer until the order
+is ready. Once the order is ready, serve_order() is called, which invokes
+V() on the semaphore, signaling that the customer thread can wake up and
+either produce more orders or go home.
+
+The fill_order() function can be thought of as a wrapper to the mix() function
+in that it simply manages access to the bottles used to mix the drinks in such
+a way that deadlocks do not occur and bottle access is mutually exclusive.
+Since the mix() function simply increments the number of doses for up to
+DRINK_COMPLEXITY bottles used in the drink, fill_order() only needs to acquire
+and release locks on those specific bottles before and after calling mix()
+to achieve mutual exclusion. This way, multiple bartender threads can mix()
+concurrently if the orders consist of a disjoint subset of drinks. We
+implemented this by creating a global `bottle_locks` array to store individual
+locks for each bottle, acquiring them in fill_order() as needed.
+
+Since there is guarantee on the order of bottles requested by customers,
+there is the possibility of multiple customers ordering drinks from the same
+bottles but in different orders, with the OS interleaving the orders in such a
+way that a deadlock occurs. As such, we had to employ a deadlock prevention
+scheme to avoid cyclic wait conditions, implemented sorting (using quicksort())
+the `order->requested_bottles` array before acquiring locks for each requested
+bottle. This ensured a consistent resource ordering convention, requiring that
+all threads acquire locks in the same order.
+
+As locks in OS/161 are not re-entrant, customers may request multiple doses
+from the same bottle in a single order, causing a bartender to block against
+itself if it tried to acquire the same lock more than once (essentially
+causing a single-process deadlock). To prevent this, bartenders call
+lock_do_i_hold() to check if they already hold the lock before
+re-requesting it.
+
+Finally, our solution ensures that all locks, semaphores and condition
+variables used are appropriately freed. Our bar_open() function initially
+creates the global locks, including one for each of the bottles and our
+bar_close() correspondingly destroys these synchronisation primitives.
diff --unidirectional-new-file -EdbwBr -u -X /home/cs3231/assigns/asst1/src/../diffex /home/cs3231/assigns/asst1/src/kern/asst1/Makefile /import/ravel/3/z5059988/cs3231/asst1-src/kern/asst1/Makefile
--- kern/asst1/Makefile	1970-01-01 10:00:00.000000000 +1000
+++ kern/asst1/Makefile	2018-03-28 11:47:48.000000000 +1100
@@ -0,0 +1,15 @@
+make:
+	cd ../compile/ASST? && bmake && bmake install
+
+run:
+	cd ../../../root && sys161 kernel "$(args)"
+
+run-gdb:
+	cd ../../../root && sys161 -w kernel "$(args)"
+
+gdb:
+	cd ../../../root && os161-gdb kernel
+
+conf:
+	cd ../../ && ./configure && cd kern/conf && ./config ASST? && \
+	cd ../compile/ASST? && bmake depend && bmake && bmake install
diff --unidirectional-new-file -EdbwBr -u -X /home/cs3231/assigns/asst1/src/../diffex /home/cs3231/assigns/asst1/src/kern/asst1/Queue.c /import/ravel/3/z5059988/cs3231/asst1-src/kern/asst1/Queue.c
--- kern/asst1/Queue.c	1970-01-01 10:00:00.000000000 +1000
+++ kern/asst1/Queue.c	2018-03-21 18:53:45.000000000 +1100
@@ -0,0 +1,86 @@
+#include <types.h>
+#include <lib.h>
+
+#include "item.h"
+#include "Queue.h"
+
+typedef struct node *link;
+
+typedef struct node {
+	item data;
+	link next;
+} node;
+
+//list-like concrete representation of queue
+typedef struct queue {
+	link head, tail;
+	unsigned long length;
+} queue;
+
+//creates and returns a new empty queue
+Queue create_queue(void) {
+	Queue new = kmalloc(sizeof(queue));
+	KASSERT(new != NULL);
+	new->length = 0;
+	new->head = new->tail = NULL;
+	return new;
+}
+
+//frees all memory associated with a given queue
+void dispose_queue(Queue q) {
+	KASSERT(q != NULL);
+	item temp;
+	while (is_queue_empty(q) == false) {
+		temp = dequeue(q);
+		del(temp);
+	}
+	kfree(q);
+}
+
+//inserts a new item at the back of a given queue
+void enqueue(Queue q, item data) {
+	KASSERT(q != NULL);
+	link new = kmalloc(sizeof(node));
+	KASSERT(new != NULL);
+	new->data = copy(data);
+	new->next = NULL;
+	if (is_queue_empty(q) == true) {
+		q->head = new;
+	} else {
+		q->tail->next = new;
+	}
+	q->tail = new;
+	q->length++;
+}
+
+//removes and returns a copy of the front item of a given queue
+item dequeue(Queue q) {
+	KASSERT(q != NULL);
+	KASSERT(is_queue_empty(q) == false);
+	link front = q->head;
+	item data = copy(front->data);
+	q->head = front->next;
+	del(front->data);
+	kfree(front);
+	q->length--;
+	return data;
+}
+
+//returns the data at the front of a given queue
+item get_head(Queue q) {
+	KASSERT(q != NULL);
+	KASSERT(is_queue_empty(q) == false);
+	return q->head->data;
+}
+
+//returns the length of a given queue
+unsigned long get_queue_length(Queue q) {
+	KASSERT(q != NULL);
+	return q->length;
+}
+
+//indicates whether a given queue is empty
+bool is_queue_empty(Queue q) {
+	KASSERT(q != NULL);
+	return q->length == 0;
+}
diff --unidirectional-new-file -EdbwBr -u -X /home/cs3231/assigns/asst1/src/../diffex /home/cs3231/assigns/asst1/src/kern/asst1/Queue.h /import/ravel/3/z5059988/cs3231/asst1-src/kern/asst1/Queue.h
--- kern/asst1/Queue.h	1970-01-01 10:00:00.000000000 +1000
+++ kern/asst1/Queue.h	2018-03-21 18:53:45.000000000 +1100
@@ -0,0 +1,23 @@
+#include <types.h>
+
+#include "item.h"
+
+#ifndef QUEUE_H
+#define QUEUE_H
+
+typedef struct queue *Queue;
+
+//queue initialisation
+Queue create_queue(void);
+void dispose_queue(Queue q);
+
+//queue progression
+void enqueue(Queue q, item data);
+item dequeue(Queue q);
+
+//queue query
+item get_head(Queue q);
+unsigned long get_queue_length(Queue q);
+bool is_queue_empty(Queue q);
+
+#endif
diff --unidirectional-new-file -EdbwBr -u -X /home/cs3231/assigns/asst1/src/../diffex /home/cs3231/assigns/asst1/src/kern/asst1/bar-tests/bar_driver.c /import/ravel/3/z5059988/cs3231/asst1-src/kern/asst1/bar-tests/bar_driver.c
--- kern/asst1/bar-tests/bar_driver.c	1970-01-01 10:00:00.000000000 +1000
+++ kern/asst1/bar-tests/bar_driver.c	2018-03-31 13:43:57.000000000 +1100
@@ -0,0 +1,344 @@
+#include "opt-synchprobs.h"
+#include <types.h>
+#include <lib.h>
+#include <synch.h>
+#include <test.h>
+#include <thread.h>
+
+#include "bar_driver.h"
+
+
+/*
+ * DEFINE THIS MACRO TO SWITCH ON MORE PRINTING
+ *
+ * Note: Your solution should work whether printing is on or off
+ *
+ */
+
+/* #define PRINT_ON */
+
+/* this semaphore is for cleaning up at the end. */
+static struct semaphore *alldone;
+
+/*
+ * Data type used to track number of doses each bottle gives
+ */
+
+struct bottle {
+        int doses;
+};
+
+struct bottle bottles[NBOTTLES];
+
+static int customers;
+static struct lock *cust_lock;
+
+/* A function used to manage staff leaving */
+
+static void go_home(void);
+
+/*
+ * **********************************************************************
+ * CUSTOMERS
+ *
+ * Customers are rather simple, they arrive and give their order to a
+ * bartender and wait for their drink.
+ *
+ * Eventually their glass arrives with the requested contents (exactly
+ * as requested), they drink until the glass is empty, take a short
+ * break, and do it all again until they have emptied the desired
+ * number of glasses (customers passing out is not simulated).
+ *
+ * Lastly, they indicate to the bar staff that they have
+ * finished for the day by calling go_home()
+ *
+ */
+
+static void customer(void *unusedpointer, unsigned long customernum)
+{
+        struct barorder order;
+        int i,j;
+
+        (void) unusedpointer; /* avoid compiler warning */
+
+        order.go_home_flag = 0;
+        int num_orders = (random() % 20) + 1; /* randomise the number of orders */
+
+        i = 0; /* count number of iterations */
+        do {
+
+
+#ifdef PRINT_ON
+                kprintf("C %ld is ordering\n", customernum);
+#endif
+
+                /* Clear away previously-requested ingredients and select a new drink */
+                for (j = 0; j < DRINK_COMPLEXITY; j++) {
+                        order.requested_bottles[j] = 0;
+                }
+
+                /* randomise the specific drinks and number of overall drinks*/
+                int num_drinks = (random() % DRINK_COMPLEXITY) + 1;
+                for (int k = 0; k < num_drinks; ++k) {
+                        order.requested_bottles[k] = (random() % NBOTTLES) + 1;
+                }
+
+                /* order the drink, this blocks until the order is fulfilled */
+                order_drink(&order);
+
+#ifdef PRINT_ON
+                kprintf("C %ld drinking %d, %d, %d\n",
+                                customernum,
+                                order.glass.contents[0],
+                                order.glass.contents[1],
+                                order.glass.contents[2]);
+#endif
+
+                /* Drink up */
+                for (j = 0; j < DRINK_COMPLEXITY; j++) {
+                        order.glass.contents[j] = 0;
+                }
+
+
+                /* I needed that break.... */
+                thread_yield();
+
+                i++;
+        } while (i < num_orders); /* keep going until .... */
+
+#ifdef PRINT_ON
+        kprintf("C %ld going home\n", customernum);
+#else
+        (void)customernum;
+#endif
+
+        /*
+         * Now we go home.
+         */
+        go_home();
+        V(alldone);
+}
+
+
+/*
+ * **********************************************************************
+ * BARTENDERS
+ *
+ * bartenders are only slightly more complicated than the customers.
+ * They take_orders, and if valid, they fill them and serve them.
+ * When all the customers have left, the bartenders go home.
+ *
+ *
+ */
+static void bartender(void *unusedpointer, unsigned long staff)
+{
+
+        struct barorder *order;
+        int i;
+
+        /* avoid compiler warning */
+        (void)unusedpointer;
+        (void)staff;
+
+        i = 0; /* count orders filled for stats */
+        while (1) {
+
+#ifdef PRINT_ON
+                kprintf("S %ld taking order\n", staff);
+#endif
+
+                order = take_order();
+
+                if (order->go_home_flag == 0) {
+
+#ifdef PRINT_ON
+                        kprintf("S %ld filling\n", staff);
+#endif
+
+
+                        i++;
+                        fill_order(order);
+
+#ifdef PRINT_ON
+                        kprintf("S %ld serving\n", staff);
+#endif
+
+                        serve_order(order);
+                } else {
+                        /* Immediately return the order without filling, and then go home */
+                        serve_order(order);
+                        break;
+                }
+
+        };
+
+#ifdef PRINT_ON
+        kprintf("S %ld going home after mixing %d drinks\n", staff, i);
+#endif
+        V(alldone);
+}
+
+
+/*
+ * **********************************************************************
+ * RUN THE BAR
+ *
+ * This routine sets up the bar prior to opening and cleans up after
+ * closing.
+ *
+ * It calls two routines (bar_open() and bar_close() in bar.c) in which
+ * you can insert your own initialisation code.
+ *
+ * It also prints some statistics at the end.
+ *
+ */
+
+int run_bar(int nargs, char **args)
+{
+        int i, result;
+
+        (void) nargs; /* avoid compiler warnings */
+        (void) args;
+
+        /* this semaphore indicates everybody has gone home */
+        alldone = sem_create("alldone", 0);
+        if (alldone == NULL) {
+                panic("run_bar: out of memory\n");
+        }
+
+        /* initialise the bottle doses to 0 */
+        for (i = 0 ; i < NBOTTLES; i++) {
+                bottles[i].doses = 0;
+        }
+
+        /* initialise the count of customers and create a lock to
+           facilitate updating the counter by multiple threads */
+        customers = NCUSTOMERS;
+
+        cust_lock = lock_create("cust lock");
+        if (cust_lock == NULL) {
+                panic("no memory");
+        }
+
+        /**********************************************************************
+         * call your routine that initialises the rest of the bar
+         */
+        bar_open();
+
+        /* Start the bartenders */
+        for (i = 0; i<NBARTENDERS; i++) {
+                result = thread_fork("bartender thread", NULL,
+                                     &bartender, NULL, i);
+                if (result) {
+                        panic("run_bar: thread_fork failed: %s\n",
+                              strerror(result));
+                }
+        }
+
+        /* Start the customers */
+
+        for (i=0; i<NCUSTOMERS; i++) {
+                result = thread_fork("customer thread", NULL,
+                                     &customer, NULL, i);
+                if (result) {
+                        panic("run_bar: thread_fork failed: %s\n",
+                              strerror(result));
+                }
+        }
+
+        /* Wait for everybody to finish. */
+        for (i = 0; i < NCUSTOMERS + NBARTENDERS; i++) {
+                P(alldone);
+        }
+
+        for (i = 0; i < NBOTTLES; i++) {
+                kprintf("Bottle %d used for %d doses\n", i + 1,
+                        bottles[i].doses);
+        }
+
+        /***********************************************************************
+         * Call your bar clean up routine
+         */
+        bar_close();
+
+        lock_destroy(cust_lock);
+        sem_destroy(alldone);
+        kprintf("The bar is closed, bye!!!\n");
+        return 0;
+}
+
+
+
+/*
+ * **********************************************************************
+ * MIX
+ *
+ * This function take a glass and an order and mixes the
+ * drink as required. It does it such that the contents
+ * EXACTLY matches the request.
+ *
+ * Yes, mix counts double and triple servings of the same tint.
+ *
+ * MIX NEEDS THE ROUTINE THAT CALLS IT TO ENSURE THAT MIX HAS EXCLUSIVE
+ * ACCESS TO THE BOTTLES IT NEEDS. And ideally, only exclusive access to
+ * the tints that are required in the mix.
+ *
+ * YOU MUST USE THIS MIX FUNCTION TO FILL GLASSES. We use it for
+ * testing when marking.
+ *
+ */
+
+void mix(struct barorder *order)
+{
+        int i;
+
+        /*
+         * add drinks to the glass in order given and increment number of
+         * doses from particular bottle
+         */
+
+        for (i = 0; i < DRINK_COMPLEXITY; i++){
+                int bottle;
+                bottle = order->requested_bottles[i];
+                order->glass.contents[i] = bottle;
+
+                if (bottle > NBOTTLES) {
+                        panic("Unknown bottle");
+                }
+                if (bottle > 0) {
+                        bottles[bottle-1].doses++;
+                }
+        }
+}
+
+/*
+ * go_home()
+ *
+ * This function is called by customers when they go home. It is used
+ * to keep track of the number of remaining customers to allow bartender
+ * threads to exit when no customers remain.
+ */
+
+
+static void go_home(void)
+{
+
+        lock_acquire(cust_lock);
+        customers --;
+
+        /* the last customer to leave tells the staff to go home */
+        if (customers == 0) {
+                struct barorder go_home_order;
+                int i;
+                lock_release(cust_lock); /* don't hold the lock longer than strictly needed */
+                go_home_order.go_home_flag = 1;
+
+                for (i = 0; i < NBARTENDERS; i++) {
+                        order_drink(&go_home_order); /* returns without order being filled */
+                }
+        } else {
+                lock_release(cust_lock);
+        }
+}
+
+
diff --unidirectional-new-file -EdbwBr -u -X /home/cs3231/assigns/asst1/src/../diffex /home/cs3231/assigns/asst1/src/kern/asst1/bar.c /import/ravel/3/z5059988/cs3231/asst1-src/kern/asst1/bar.c
--- kern/asst1/bar.c	2018-03-09 13:16:22.000000000 +1100
+++ kern/asst1/bar.c	2018-03-28 11:37:16.000000000 +1100
@@ -6,17 +6,14 @@
 
 #include "bar.h"
 #include "bar_driver.h"
-
-
-
-/*
- * **********************************************************************
- * YOU ARE FREE TO CHANGE THIS FILE BELOW THIS POINT AS YOU SEE FIT
- *
- */
+#include "Queue.h"
+#include "quicksort.h"
 
 /* Declare any globals you need here (e.g. locks, etc...) */
-
+Queue pending_orders;
+struct lock *que_lock;
+struct cv *order_made;
+struct lock *bottle_locks[NBOTTLES];
 
 /*
  * **********************************************************************
@@ -31,15 +28,17 @@
  * function makes the order available to staff threads and then blocks
  * until a bartender has filled the glass with the appropriate drinks.
  */
-
-void order_drink(struct barorder *order)
-{
-        (void) order; /* Avoid compiler warning, remove when used */
-        panic("You need to write some code!!!!\n");
+void order_drink(struct barorder *order) {
+	order->order_ready = sem_create("order ready", 0);
+	if (order->order_ready == NULL) panic("%s: order_ready create failed", __FILE__);
+	lock_acquire(que_lock);
+	enqueue(pending_orders, order);
+	cv_signal(order_made, que_lock);
+	lock_release(que_lock);
+	P(order->order_ready);
+	sem_destroy(order->order_ready);
 }
 
-
-
 /*
  * **********************************************************************
  * FUNCTIONS EXECUTED BY BARTENDER THREADS
@@ -53,11 +52,11 @@
  * customers. When submitted, it returns a pointer to the order.
  *
  */
-
-struct barorder *take_order(void)
-{
-        struct barorder *ret = NULL;
-
+struct barorder *take_order(void) {
+	lock_acquire(que_lock);
+	while (is_queue_empty(pending_orders)) cv_wait(order_made, que_lock);
+	struct barorder *ret = dequeue(pending_orders);
+	lock_release(que_lock);
         return ret;
 }
 
@@ -72,18 +70,33 @@
  * REQUIRED BOTTLES (AND, IDEALLY, ONLY THE BOTTLES) IT NEEDS TO USE TO
  * FILL THE ORDER.
  */
+void fill_order(struct barorder *order) {
 
-void fill_order(struct barorder *order)
-{
+	/* enforce resource ordering to prevent deadlock */
+	quicksort(order->requested_bottles, 0, DRINK_COMPLEXITY - 1);
 
-        /* add any sync primitives you need to ensure mutual exclusion
-           holds as described */
+	/* lock all bottles needed for the order */
+	for (int i = 0; i < DRINK_COMPLEXITY; ++i) {
+		int bottle = order->requested_bottles[i];
+		if (bottle > NBOTTLES) panic("Unknown bottle");
+		if (bottle <= 0) continue;
+		struct lock *l = bottle_locks[bottle - 1];
+		if (!lock_do_i_hold(l)) lock_acquire(l);
+	}
 
         /* the call to mix must remain */
         mix(order);
 
+	/* release all bottle locks */
+	for (int i = 0; i < DRINK_COMPLEXITY; ++i) {
+		int bottle = order->requested_bottles[i];
+		if (bottle > NBOTTLES) panic("Unknown bottle");
+		if (bottle <= 0) continue;
+		struct lock *l = bottle_locks[bottle - 1];
+		if (lock_do_i_hold(l)) lock_release(l);
 }
 
+}
 
 /*
  * serve_order()
@@ -91,15 +104,10 @@
  * Takes a filled order and makes it available to (unblocks) the
  * waiting customer.
  */
-
-void serve_order(struct barorder *order)
-{
-        (void) order; /* avoid a compiler warning, remove when you
-                         start */
+void serve_order(struct barorder *order) {
+	V(order->order_ready);
 }
 
-
-
 /*
  * **********************************************************************
  * INITIALISATION AND CLEANUP FUNCTIONS
@@ -114,10 +121,16 @@
  * bartenders and customers. Typically, allocation and initialisation of
  * synch primitive and variable.
  */
-
-void bar_open(void)
-{
-
+void bar_open(void) {
+	pending_orders = create_queue();
+	que_lock = lock_create("queue lock");
+	if (que_lock == NULL) panic("%s: que_lock create failed", __FILE__);
+	order_made = cv_create("order made");
+	if (order_made == NULL) panic("%s: order_made create failed", __FILE__);
+	for (int i = 0; i < NBOTTLES; ++i) {
+		bottle_locks[i] = lock_create("bottle lock");
+		if (bottle_locks[i] == NULL) panic("%s: bottle_lock %d create failed", __FILE__, i);
+	}
 }
 
 /*
@@ -126,9 +139,11 @@
  * Perform any cleanup after the bar has closed and everybody
  * has gone home.
  */
-
-void bar_close(void)
-{
-
+void bar_close(void) {
+	dispose_queue(pending_orders);
+	lock_destroy(que_lock);
+	cv_destroy(order_made);
+	for (int i = 0; i < NBOTTLES; ++i) {
+		lock_destroy(bottle_locks[i]);
+	}
 }
-
diff --unidirectional-new-file -EdbwBr -u -X /home/cs3231/assigns/asst1/src/../diffex /home/cs3231/assigns/asst1/src/kern/asst1/bar.h /import/ravel/3/z5059988/cs3231/asst1-src/kern/asst1/bar.h
--- kern/asst1/bar.h	2018-03-09 13:16:22.000000000 +1100
+++ kern/asst1/bar.h	2018-03-28 11:37:16.000000000 +1100
@@ -1,25 +1,21 @@
-#ifndef BAR_H
-#define BAR_H
 #include <synch.h>
 
 #include "barglass.h"
 
+#ifndef BAR_H
+#define BAR_H
+
 /*
- * You are free to add anything you think you require to this file,
- * with the exceptions noted below.
+ * struct barorder is the main type referred to in the code. It must
+ * be preserved as noted for our later testing to work
  */
-
-
-/* struct barorder is the main type referred to in the code. It must
-   be preserved as noted for our later testing to work */
-
 struct barorder {
         unsigned int requested_bottles[DRINK_COMPLEXITY]; /* Do not change */
         int go_home_flag;                                 /* Do not change */
         struct glass glass;                               /* Do not change */
 
         /* This struct can be extended with your own entries below here */ 
-
+	struct semaphore *order_ready; /* used to block until order ready */
 };
 
 #endif
diff --unidirectional-new-file -EdbwBr -u -X /home/cs3231/assigns/asst1/src/../diffex /home/cs3231/assigns/asst1/src/kern/asst1/item.h /import/ravel/3/z5059988/cs3231/asst1-src/kern/asst1/item.h
--- kern/asst1/item.h	1970-01-01 10:00:00.000000000 +1000
+++ kern/asst1/item.h	2018-03-21 18:53:45.000000000 +1100
@@ -0,0 +1,18 @@
+#include "bar.h"
+
+#ifndef ITEM_H
+#define ITEM_H
+
+typedef struct barorder *item;
+typedef item key;
+
+#define key(it) ((it))
+#define del(it) ((it) = (it))
+#define copy(x) ((x))
+#define eq(x,y) ((x) == (y))
+#define lt(x,y) ((x) < (y))
+#define le(x,y) ((x) <= (y))
+#define gt(x,y) ((x) > (y))
+#define ge(x,y) ((x) >= (y))
+
+#endif
diff --unidirectional-new-file -EdbwBr -u -X /home/cs3231/assigns/asst1/src/../diffex /home/cs3231/assigns/asst1/src/kern/asst1/math.c /import/ravel/3/z5059988/cs3231/asst1-src/kern/asst1/math.c
--- kern/asst1/math.c	2018-03-09 13:16:22.000000000 +1100
+++ kern/asst1/math.c	2018-03-28 11:37:16.000000000 +1100
@@ -34,15 +28,6 @@
 /* We use a semaphore to wait for adder() threads to finish */
 struct semaphore *finished;
 
-
-/*
- * **********************************************************************
- * ADD YOUR OWN VARIABLES HERE AS NEEDED
- * **********************************************************************
- */
-
-
-
 /*
  * adder()
  *
@@ -63,21 +48,16 @@
  * + only synchronise the critical section, no more.
  *
  */
-
-static void adder(void * unusedpointer, unsigned long addernumber)
-{
+static void adder(void *unusedpointer, unsigned long addernumber) {
         unsigned long int a, b;
         int flag = 1;
 
-        /*
-         * Avoid unused variable warnings.
-         */
-        (void) unusedpointer; /* remove this line if variable is used */
-
         while (flag) {
-                /* loop doing increments until we achieve the overall number
-                   of increments */
+		/* loop doing increments until we achieve the overall number of increments */
 
+		/* start of critical section */
+		struct lock *counter_lock = (struct lock*) unusedpointer;
+		lock_acquire(counter_lock);
                 a = counter;
                 if (a < NADDS) {
                         counter = counter + 1;
@@ -88,12 +68,13 @@
 
                         /* check we are getting sane results */
                         if (a + 1 != b) {
-                                kprintf("In thread %ld, %ld + 1 == %ld?\n",
-                                        addernumber, a, b) ;
+				kprintf("In thread %ld, %ld + 1 == %ld?\n", addernumber, a, b);
                         }
                 } else {
                         flag = 0;
                 }
+		lock_release(counter_lock);
+		/* end of critical section */
         }
 
         /* signal the main thread we have finished and then exit */
@@ -112,9 +93,7 @@
  * + Starts the define number of adder threads
  * + waits, prints statistics, cleans up, and exits
  */
-
-int maths (int data1, char **data2)
-{
+int maths (int data1, char **data2) {
         int index, error;
         unsigned long int sum;
 
@@ -129,7 +107,7 @@
         finished = sem_create("finished", 0);
 
         if (finished == NULL) {
-                panic("maths: sem create failed");
+		panic("%s: sem create failed", __FILE__);
         }
 
         /*
@@ -137,7 +115,10 @@
          * INSERT ANY INITIALISATION CODE YOU REQUIRE HERE
          * ********************************************************************
          */
-
+	struct lock *counter_lock = lock_create("counter lock");
+	if (counter_lock == NULL) {
+		panic("%s: counter_lock create failed", __FILE__);
+ 	}
 
         /*
          * Start NADDERS adder() threads.
@@ -142,12 +123,9 @@
         /*
          * Start NADDERS adder() threads.
          */
-
         kprintf("Starting %d adder threads\n", NADDERS);
-
         for (index = 0; index < NADDERS; index++) {
-
-                error = thread_fork("adder thread", NULL, &adder, NULL, index);
+		error = thread_fork("adder thread", NULL, &adder, counter_lock, index);
 
                 /*
                  * panic() on error.
@@ -152,10 +130,8 @@
                 /*
                  * panic() on error.
                  */
-
                 if (error) {
-                        panic("adder: thread_fork failed: %s\n",
-                              strerror(error));
+			panic("adder: thread_fork failed: %s\n", strerror(error));
                 }
         }
 
@@ -172,8 +145,7 @@
         sum = 0;
         for (index = 0; index < NADDERS; index++) {
                 sum += adder_counters[index];
-                kprintf("Adder %d performed %ld increments.\n", index,
-                        adder_counters[index]);
+		kprintf("Adder %d performed %ld increments.\n", index, adder_counters[index]);
         }
         kprintf("The adders performed %ld increments overall\n", sum);
 
@@ -182,7 +154,7 @@
          * INSERT ANY CLEANUP CODE YOU REQUIRE HERE
          * **********************************************************************
          */
-
+	lock_destroy(counter_lock);
 
         /* clean up the semaphore we allocated earlier */
         sem_destroy(finished);
diff --unidirectional-new-file -EdbwBr -u -X /home/cs3231/assigns/asst1/src/../diffex /home/cs3231/assigns/asst1/src/kern/asst1/producer-consumer-tests/producerconsumer_driver1.c /import/ravel/3/z5059988/cs3231/asst1-src/kern/asst1/producer-consumer-tests/producerconsumer_driver1.c
--- kern/asst1/producer-consumer-tests/producerconsumer_driver1.c	1970-01-01 10:00:00.000000000 +1000
+++ kern/asst1/producer-consumer-tests/producerconsumer_driver1.c	2018-03-31 13:43:57.000000000 +1100
@@ -0,0 +1,244 @@
+/*
+ * Driver file for the producer / consumer simulation.
+ *
+ * This starts up a number of producer and consumer threads and has them
+ * communicate via the API defined in producerconsumer_driver.h, which is
+ * implemented by you in producerconsumer.c.
+ *
+ * NOTE: DO NOT RELY ON ANY CHANGES YOU MAKE TO THIS FILE, BECAUSE
+ * IT WILL BE OVERWRITTEN DURING TESTING.
+ */
+#include "opt-synchprobs.h"
+#include <types.h>  /* required by lib.h */
+#include <lib.h>    /* for kprintf */
+#include <synch.h>  /* for P(), V(), sem_* */
+#include <thread.h> /* for thread_fork() */
+#include <test.h>
+
+#include "producerconsumer_driver.h"
+
+/* The number of producers
+ * This will be changed during testing
+ */
+#define NUM_PRODUCERS 2
+
+/* The number of consumer threads
+ * This number will be changed during testing
+ */
+#define NUM_CONSUMERS 5
+
+/* Number of items each producer thread generates before
+ * exiting. This number will be changed during testing.
+ */
+#define ITEMS_TO_PRODUCE 30
+
+/* If a consumer receives more than the following number of
+ * data items, it will automatically exit. This is to help
+ * you during testing. Do not rely on it!
+ */
+#define SOMETHING_WRONG_COUNT 10000
+
+/* Semaphores which the simulator uses to determine when all
+ * producer threads and all consumer threads have finished.
+ */
+static struct semaphore *consumer_finished;
+static struct semaphore *producer_finished;
+
+/* The producer thread's only function. This function calls
+ * producer_send ITEMS_TO_PRODUCE times and then exits. NUM_PRODUCERS
+ * threads are started to run the function.
+ */
+static void
+producer_thread(void *unused_ptr, unsigned long thread_num)
+{
+        struct pc_data thedata;
+        int items_to_go = ITEMS_TO_PRODUCE;
+
+        (void)unused_ptr; /* Avoid compiler warnings */
+
+        kprintf("Producer started\n");
+
+        while(items_to_go > 0) {
+                thedata.item1 = items_to_go + (1000 * thread_num);
+                /* Set second data item as related to the first so that
+                 * the consumer can check both numbers are valid
+                 */
+                thedata.item2 = thedata.item1 + 1;
+
+                producer_send(thedata);
+
+                items_to_go = items_to_go - 1;
+        }
+
+        /* No more items... Signal that we're done. */
+        kprintf("Producer finished\n");
+        V(producer_finished);
+}
+
+/* The consumer thread's only function. NUM_CONSUMERS threads are started,
+ * each of which runs this function. The function continuously calls
+ * consumer_receive() until it receives a special data item containing
+ * two zero integers. NOTE: Don't rely on this specific protocol when designing
+ * your producer_send() and consumer_receive() functions!
+ */
+static void
+consumer_thread(void *unused_ptr, unsigned long thread_num)
+{
+        struct pc_data thedata;
+        int check_count = 0;
+
+        (void)unused_ptr;
+        (void)thread_num;
+
+        kprintf("Consumer started\n");
+
+        thedata = consumer_receive();
+
+        while (thedata.item1 != 0 || thedata.item2 != 0) {
+                if (++check_count >= SOMETHING_WRONG_COUNT) {
+                        /*
+                         * something must be wrong if we received this many
+                         * items.
+                         */
+                        break;
+                }
+
+                /* check we receive sane results */
+                if(thedata.item1 +1 != thedata.item2) {
+                        kprintf("*** Error! Unexpected data %d and %d\n",
+                                thedata.item1, thedata.item2);
+                }
+
+                thedata = consumer_receive();
+        }
+
+        if (check_count >= SOMETHING_WRONG_COUNT) {
+                kprintf("*** Error! Consumer exiting...\n");
+        } else {
+                kprintf("Consumer finished normally\n");
+        }
+
+        /* Signal that we're done. */
+        V(consumer_finished);
+}
+
+/* Create a bunch of threads to consume data. */
+static void
+start_consumer_threads()
+{
+        int i;
+        int result;
+
+        for(i = 0; i < NUM_CONSUMERS; i++) {
+                result = thread_fork("consumer thread", NULL,
+                                     consumer_thread, NULL, i);
+                if(result) {
+                        panic("start_consumer_threads: couldn't fork (%s)\n",
+                              strerror(result));
+                }
+        }
+}
+
+/* Create a bunch of threads to produce data. */
+static void
+start_producer_threads()
+{
+        int i;
+        int result;
+
+        for(i = 0; i < NUM_PRODUCERS; i++) {
+                result = thread_fork("producer thread", NULL,
+                                     producer_thread, NULL, i);
+                if(result) {
+                        panic("start_producer_threads: couldn't fork (%s)\n",
+                              strerror(result));
+                }
+        }
+}
+
+/* Wait for all producer threads to exit.
+ * Producers each produce ITEMS_TO_PRODUCE items and then signal
+ * a semaphore and exit, so waiting for them to finish means
+ * waiting on that semaphore NUM_PRODUCERS times.
+ */
+static void
+wait_for_producer_threads()
+{
+        int i;
+        kprintf("Waiting for producer threads to exit...\n");
+        for(i = 0; i < NUM_PRODUCERS; i++) {
+                P(producer_finished);
+        }
+        kprintf("All producer threads have exited.\n");
+}
+
+/* Instruct all consumer threads to exit and then wait for them
+ * to indicate that they have exited.
+ * Consumer threads run until told to stop using a special
+ * message, described below.
+ */
+static void
+stop_consumer_threads()
+{
+        int i;
+        struct pc_data thedata;
+
+        /* Our protocol for stopping consumer threads is to
+         * enqueue NUM_CONSUMERS sets of 0, 0 data items.
+         * This may change during testing, however.
+         */
+        thedata.item1 = 0;
+        thedata.item2 = 0;
+
+        for(i = 0; i < NUM_CONSUMERS; i++) {
+                producer_send(thedata);
+        }
+
+        /* Now wait for all consumers to signal completion. */
+        for(i = 0; i < NUM_CONSUMERS; i++) {
+                P(consumer_finished);
+        }
+
+}
+
+/* The main function for the simulation. */
+int
+run_producerconsumer(int nargs, char **args)
+{
+        (void) nargs; /* Avoid "unused variable" warning */
+        (void) args;
+
+        kprintf("run_producerconsumer: starting up\n");
+
+        /* Initialise synch primitives used in this simulator */
+        consumer_finished = sem_create("consumer_finished", 0);
+        if(!consumer_finished) {
+                panic("run_producerconsumer: couldn't create semaphore\n");
+        }
+
+        producer_finished = sem_create("producer_finished", 0);
+        if(!producer_finished ) {
+                panic("run_producerconsumer: couldn't create semaphore\n");
+        }
+
+        /* Run any code required to initialise synch primitives etc */
+        producerconsumer_startup();
+
+        /* Run the simulation */
+        start_consumer_threads();
+        start_producer_threads();
+
+        /* Wait for all producers and consumers to finish */
+
+        wait_for_producer_threads();
+        stop_consumer_threads();
+
+        /* Run any code required to shut down the simulation */
+        producerconsumer_shutdown();
+
+        /* Done! */
+        sem_destroy(producer_finished);
+        sem_destroy(consumer_finished);
+        return 0;
+}
+
diff --unidirectional-new-file -EdbwBr -u -X /home/cs3231/assigns/asst1/src/../diffex /home/cs3231/assigns/asst1/src/kern/asst1/producer-consumer-tests/producerconsumer_driver1.h /import/ravel/3/z5059988/cs3231/asst1-src/kern/asst1/producer-consumer-tests/producerconsumer_driver1.h
--- kern/asst1/producer-consumer-tests/producerconsumer_driver1.h	1970-01-01 10:00:00.000000000 +1000
+++ kern/asst1/producer-consumer-tests/producerconsumer_driver1.h	2018-03-31 13:43:57.000000000 +1100
@@ -0,0 +1,51 @@
+#ifndef PRODUCERCONSUMER_DRIVER_H
+#define PRODUCERCONSUMER_DRIVER_H
+
+/*  This file contains constants, types, and prototypes for the
+ *  producer consumer problem. It is included by the driver and the
+ *  file you modify so as to share the definitions between both.
+
+ *  YOU SHOULD NOT CHANGE THIS FILE
+
+ *  We will replace it in testing, so any changes will be lost.
+ */
+
+
+#define BUFFER_SIZE 10   /* The size of the bounded buffer */
+
+/*  The buffer must be exactly the size of the constant defined here.
+ *
+ * The producer_send() will block if more than this size is sent to
+ * the buffer, but won't block while there is space in the buffer.
+ */
+
+
+
+/* This is a type definition of the data that you will be passing
+ * around in your own data structures
+ */
+struct pc_data {
+        int item1;
+        int item2;
+};
+
+
+extern int run_producerconsumer(int, char**);
+
+
+
+/* These are the prototypes for the functions you need to write in
+   producerconsumer.c */
+struct pc_data consumer_receive(void); /* receive a data item, blocking
+                                       if no item is available is the
+                                       shared buffer */
+
+void producer_send(struct pc_data); /* send a data item to the shared
+                                       buffer */
+
+void producerconsumer_startup(void); /* initialise your buffer and
+                                        surrounding code */
+
+void producerconsumer_shutdown(void); /* clean up your system at the
+                                         end */
+#endif 
diff --unidirectional-new-file -EdbwBr -u -X /home/cs3231/assigns/asst1/src/../diffex /home/cs3231/assigns/asst1/src/kern/asst1/producer-consumer-tests/producerconsumer_driver2.c /import/ravel/3/z5059988/cs3231/asst1-src/kern/asst1/producer-consumer-tests/producerconsumer_driver2.c
--- kern/asst1/producer-consumer-tests/producerconsumer_driver2.c	1970-01-01 10:00:00.000000000 +1000
+++ kern/asst1/producer-consumer-tests/producerconsumer_driver2.c	2018-03-31 13:43:57.000000000 +1100
@@ -0,0 +1,244 @@
+/*
+ * Driver file for the producer / consumer simulation.
+ *
+ * This starts up a number of producer and consumer threads and has them
+ * communicate via the API defined in producerconsumer_driver.h, which is
+ * implemented by you in producerconsumer.c.
+ *
+ * NOTE: DO NOT RELY ON ANY CHANGES YOU MAKE TO THIS FILE, BECAUSE
+ * IT WILL BE OVERWRITTEN DURING TESTING.
+ */
+#include "opt-synchprobs.h"
+#include <types.h>  /* required by lib.h */
+#include <lib.h>    /* for kprintf */
+#include <synch.h>  /* for P(), V(), sem_* */
+#include <thread.h> /* for thread_fork() */
+#include <test.h>
+
+#include "producerconsumer_driver.h"
+
+/* The number of producers
+ * This will be changed during testing
+ */
+#define NUM_PRODUCERS 1
+
+/* The number of consumer threads
+ * This number will be changed during testing
+ */
+#define NUM_CONSUMERS 5
+
+/* Number of items each producer thread generates before
+ * exiting. This number will be changed during testing.
+ */
+#define ITEMS_TO_PRODUCE 30
+
+/* If a consumer receives more than the following number of
+ * data items, it will automatically exit. This is to help
+ * you during testing. Do not rely on it!
+ */
+#define SOMETHING_WRONG_COUNT 10000
+
+/* Semaphores which the simulator uses to determine when all
+ * producer threads and all consumer threads have finished.
+ */
+static struct semaphore *consumer_finished;
+static struct semaphore *producer_finished;
+
+/* The producer thread's only function. This function calls
+ * producer_send ITEMS_TO_PRODUCE times and then exits. NUM_PRODUCERS
+ * threads are started to run the function.
+ */
+static void
+producer_thread(void *unused_ptr, unsigned long thread_num)
+{
+        struct pc_data thedata;
+        int items_to_go = ITEMS_TO_PRODUCE;
+
+        (void)unused_ptr; /* Avoid compiler warnings */
+
+        kprintf("Producer started\n");
+
+        while(items_to_go > 0) {
+                thedata.item1 = items_to_go + (1000 * thread_num);
+                /* Set second data item as related to the first so that
+                 * the consumer can check both numbers are valid
+                 */
+                thedata.item2 = thedata.item1 + 1;
+
+                producer_send(thedata);
+
+                items_to_go = items_to_go - 1;
+        }
+
+        /* No more items... Signal that we're done. */
+        kprintf("Producer finished\n");
+        V(producer_finished);
+}
+
+/* The consumer thread's only function. NUM_CONSUMERS threads are started,
+ * each of which runs this function. The function continuously calls
+ * consumer_receive() until it receives a special data item containing
+ * two zero integers. NOTE: Don't rely on this specific protocol when designing
+ * your producer_send() and consumer_receive() functions!
+ */
+static void
+consumer_thread(void *unused_ptr, unsigned long thread_num)
+{
+        struct pc_data thedata;
+        int check_count = 0;
+
+        (void)unused_ptr;
+        (void)thread_num;
+
+        kprintf("Consumer started\n");
+
+        thedata = consumer_receive();
+
+        while (thedata.item1 != 0 || thedata.item2 != 0) {
+                if (++check_count >= SOMETHING_WRONG_COUNT) {
+                        /*
+                         * something must be wrong if we received this many
+                         * items.
+                         */
+                        break;
+                }
+
+                /* check we receive sane results */
+                if(thedata.item1 +1 != thedata.item2) {
+                        kprintf("*** Error! Unexpected data %d and %d\n",
+                                thedata.item1, thedata.item2);
+                }
+
+                thedata = consumer_receive();
+        }
+
+        if (check_count >= SOMETHING_WRONG_COUNT) {
+                kprintf("*** Error! Consumer exiting...\n");
+        } else {
+                kprintf("Consumer finished normally\n");
+        }
+
+        /* Signal that we're done. */
+        V(consumer_finished);
+}
+
+/* Create a bunch of threads to consume data. */
+static void
+start_consumer_threads()
+{
+        int i;
+        int result;
+
+        for(i = 0; i < NUM_CONSUMERS; i++) {
+                result = thread_fork("consumer thread", NULL,
+                                     consumer_thread, NULL, i);
+                if(result) {
+                        panic("start_consumer_threads: couldn't fork (%s)\n",
+                              strerror(result));
+                }
+        }
+}
+
+/* Create a bunch of threads to produce data. */
+static void
+start_producer_threads()
+{
+        int i;
+        int result;
+
+        for(i = 0; i < NUM_PRODUCERS; i++) {
+                result = thread_fork("producer thread", NULL,
+                                     producer_thread, NULL, i);
+                if(result) {
+                        panic("start_producer_threads: couldn't fork (%s)\n",
+                              strerror(result));
+                }
+        }
+}
+
+/* Wait for all producer threads to exit.
+ * Producers each produce ITEMS_TO_PRODUCE items and then signal
+ * a semaphore and exit, so waiting for them to finish means
+ * waiting on that semaphore NUM_PRODUCERS times.
+ */
+static void
+wait_for_producer_threads()
+{
+        int i;
+        kprintf("Waiting for producer threads to exit...\n");
+        for(i = 0; i < NUM_PRODUCERS; i++) {
+                P(producer_finished);
+        }
+        kprintf("All producer threads have exited.\n");
+}
+
+/* Instruct all consumer threads to exit and then wait for them
+ * to indicate that they have exited.
+ * Consumer threads run until told to stop using a special
+ * message, described below.
+ */
+static void
+stop_consumer_threads()
+{
+        int i;
+        struct pc_data thedata;
+
+        /* Our protocol for stopping consumer threads is to
+         * enqueue NUM_CONSUMERS sets of 0, 0 data items.
+         * This may change during testing, however.
+         */
+        thedata.item1 = 0;
+        thedata.item2 = 0;
+
+        for(i = 0; i < NUM_CONSUMERS; i++) {
+                producer_send(thedata);
+        }
+
+        /* Now wait for all consumers to signal completion. */
+        for(i = 0; i < NUM_CONSUMERS; i++) {
+                P(consumer_finished);
+        }
+
+}
+
+/* The main function for the simulation. */
+int
+run_producerconsumer(int nargs, char **args)
+{
+        (void) nargs; /* Avoid "unused variable" warning */
+        (void) args;
+
+        kprintf("run_producerconsumer: starting up\n");
+
+        /* Initialise synch primitives used in this simulator */
+        consumer_finished = sem_create("consumer_finished", 0);
+        if(!consumer_finished) {
+                panic("run_producerconsumer: couldn't create semaphore\n");
+        }
+
+        producer_finished = sem_create("producer_finished", 0);
+        if(!producer_finished ) {
+                panic("run_producerconsumer: couldn't create semaphore\n");
+        }
+
+        /* Run any code required to initialise synch primitives etc */
+        producerconsumer_startup();
+
+        /* Run the simulation */
+        start_consumer_threads();
+        start_producer_threads();
+
+        /* Wait for all producers and consumers to finish */
+
+        wait_for_producer_threads();
+        stop_consumer_threads();
+
+        /* Run any code required to shut down the simulation */
+        producerconsumer_shutdown();
+
+        /* Done! */
+        sem_destroy(producer_finished);
+        sem_destroy(consumer_finished);
+        return 0;
+}
+
diff --unidirectional-new-file -EdbwBr -u -X /home/cs3231/assigns/asst1/src/../diffex /home/cs3231/assigns/asst1/src/kern/asst1/producer-consumer-tests/producerconsumer_driver2.h /import/ravel/3/z5059988/cs3231/asst1-src/kern/asst1/producer-consumer-tests/producerconsumer_driver2.h
--- kern/asst1/producer-consumer-tests/producerconsumer_driver2.h	1970-01-01 10:00:00.000000000 +1000
+++ kern/asst1/producer-consumer-tests/producerconsumer_driver2.h	2018-03-31 13:43:57.000000000 +1100
@@ -0,0 +1,51 @@
+#ifndef PRODUCERCONSUMER_DRIVER_H
+#define PRODUCERCONSUMER_DRIVER_H
+
+/*  This file contains constants, types, and prototypes for the
+ *  producer consumer problem. It is included by the driver and the
+ *  file you modify so as to share the definitions between both.
+
+ *  YOU SHOULD NOT CHANGE THIS FILE
+
+ *  We will replace it in testing, so any changes will be lost.
+ */
+
+
+#define BUFFER_SIZE 22   /* The size of the bounded buffer */
+
+/*  The buffer must be exactly the size of the constant defined here.
+ *
+ * The producer_send() will block if more than this size is sent to
+ * the buffer, but won't block while there is space in the buffer.
+ */
+
+
+
+/* This is a type definition of the data that you will be passing
+ * around in your own data structures
+ */
+struct pc_data {
+        int item1;
+        int item2;
+};
+
+
+extern int run_producerconsumer(int, char**);
+
+
+
+/* These are the prototypes for the functions you need to write in
+   producerconsumer.c */
+struct pc_data consumer_receive(void); /* receive a data item, blocking
+                                       if no item is available is the
+                                       shared buffer */
+
+void producer_send(struct pc_data); /* send a data item to the shared
+                                       buffer */
+
+void producerconsumer_startup(void); /* initialise your buffer and
+                                        surrounding code */
+
+void producerconsumer_shutdown(void); /* clean up your system at the
+                                         end */
+#endif 
diff --unidirectional-new-file -EdbwBr -u -X /home/cs3231/assigns/asst1/src/../diffex /home/cs3231/assigns/asst1/src/kern/asst1/producer-consumer-tests/producerconsumer_driver3.c /import/ravel/3/z5059988/cs3231/asst1-src/kern/asst1/producer-consumer-tests/producerconsumer_driver3.c
--- kern/asst1/producer-consumer-tests/producerconsumer_driver3.c	1970-01-01 10:00:00.000000000 +1000
+++ kern/asst1/producer-consumer-tests/producerconsumer_driver3.c	2018-03-31 13:43:57.000000000 +1100
@@ -0,0 +1,244 @@
+/*
+ * Driver file for the producer / consumer simulation.
+ *
+ * This starts up a number of producer and consumer threads and has them
+ * communicate via the API defined in producerconsumer_driver.h, which is
+ * implemented by you in producerconsumer.c.
+ *
+ * NOTE: DO NOT RELY ON ANY CHANGES YOU MAKE TO THIS FILE, BECAUSE
+ * IT WILL BE OVERWRITTEN DURING TESTING.
+ */
+#include "opt-synchprobs.h"
+#include <types.h>  /* required by lib.h */
+#include <lib.h>    /* for kprintf */
+#include <synch.h>  /* for P(), V(), sem_* */
+#include <thread.h> /* for thread_fork() */
+#include <test.h>
+
+#include "producerconsumer_driver.h"
+
+/* The number of producers
+ * This will be changed during testing
+ */
+#define NUM_PRODUCERS 5
+
+/* The number of consumer threads
+ * This number will be changed during testing
+ */
+#define NUM_CONSUMERS 1
+
+/* Number of items each producer thread generates before
+ * exiting. This number will be changed during testing.
+ */
+#define ITEMS_TO_PRODUCE 30
+
+/* If a consumer receives more than the following number of
+ * data items, it will automatically exit. This is to help
+ * you during testing. Do not rely on it!
+ */
+#define SOMETHING_WRONG_COUNT 10000
+
+/* Semaphores which the simulator uses to determine when all
+ * producer threads and all consumer threads have finished.
+ */
+static struct semaphore *consumer_finished;
+static struct semaphore *producer_finished;
+
+/* The producer thread's only function. This function calls
+ * producer_send ITEMS_TO_PRODUCE times and then exits. NUM_PRODUCERS
+ * threads are started to run the function.
+ */
+static void
+producer_thread(void *unused_ptr, unsigned long thread_num)
+{
+        struct pc_data thedata;
+        int items_to_go = ITEMS_TO_PRODUCE;
+
+        (void)unused_ptr; /* Avoid compiler warnings */
+
+        kprintf("Producer started\n");
+
+        while(items_to_go > 0) {
+                thedata.item1 = items_to_go + (1000 * thread_num);
+                /* Set second data item as related to the first so that
+                 * the consumer can check both numbers are valid
+                 */
+                thedata.item2 = thedata.item1 + 1;
+
+                producer_send(thedata);
+
+                items_to_go = items_to_go - 1;
+        }
+
+        /* No more items... Signal that we're done. */
+        kprintf("Producer finished\n");
+        V(producer_finished);
+}
+
+/* The consumer thread's only function. NUM_CONSUMERS threads are started,
+ * each of which runs this function. The function continuously calls
+ * consumer_receive() until it receives a special data item containing
+ * two zero integers. NOTE: Don't rely on this specific protocol when designing
+ * your producer_send() and consumer_receive() functions!
+ */
+static void
+consumer_thread(void *unused_ptr, unsigned long thread_num)
+{
+        struct pc_data thedata;
+        int check_count = 0;
+
+        (void)unused_ptr;
+        (void)thread_num;
+
+        kprintf("Consumer started\n");
+
+        thedata = consumer_receive();
+
+        while (thedata.item1 != 0 || thedata.item2 != 0) {
+                if (++check_count >= SOMETHING_WRONG_COUNT) {
+                        /*
+                         * something must be wrong if we received this many
+                         * items.
+                         */
+                        break;
+                }
+
+                /* check we receive sane results */
+                if(thedata.item1 +1 != thedata.item2) {
+                        kprintf("*** Error! Unexpected data %d and %d\n",
+                                thedata.item1, thedata.item2);
+                }
+
+                thedata = consumer_receive();
+        }
+
+        if (check_count >= SOMETHING_WRONG_COUNT) {
+                kprintf("*** Error! Consumer exiting...\n");
+        } else {
+                kprintf("Consumer finished normally\n");
+        }
+
+        /* Signal that we're done. */
+        V(consumer_finished);
+}
+
+/* Create a bunch of threads to consume data. */
+static void
+start_consumer_threads()
+{
+        int i;
+        int result;
+
+        for(i = 0; i < NUM_CONSUMERS; i++) {
+                result = thread_fork("consumer thread", NULL,
+                                     consumer_thread, NULL, i);
+                if(result) {
+                        panic("start_consumer_threads: couldn't fork (%s)\n",
+                              strerror(result));
+                }
+        }
+}
+
+/* Create a bunch of threads to produce data. */
+static void
+start_producer_threads()
+{
+        int i;
+        int result;
+
+        for(i = 0; i < NUM_PRODUCERS; i++) {
+                result = thread_fork("producer thread", NULL,
+                                     producer_thread, NULL, i);
+                if(result) {
+                        panic("start_producer_threads: couldn't fork (%s)\n",
+                              strerror(result));
+                }
+        }
+}
+
+/* Wait for all producer threads to exit.
+ * Producers each produce ITEMS_TO_PRODUCE items and then signal
+ * a semaphore and exit, so waiting for them to finish means
+ * waiting on that semaphore NUM_PRODUCERS times.
+ */
+static void
+wait_for_producer_threads()
+{
+        int i;
+        kprintf("Waiting for producer threads to exit...\n");
+        for(i = 0; i < NUM_PRODUCERS; i++) {
+                P(producer_finished);
+        }
+        kprintf("All producer threads have exited.\n");
+}
+
+/* Instruct all consumer threads to exit and then wait for them
+ * to indicate that they have exited.
+ * Consumer threads run until told to stop using a special
+ * message, described below.
+ */
+static void
+stop_consumer_threads()
+{
+        int i;
+        struct pc_data thedata;
+
+        /* Our protocol for stopping consumer threads is to
+         * enqueue NUM_CONSUMERS sets of 0, 0 data items.
+         * This may change during testing, however.
+         */
+        thedata.item1 = 0;
+        thedata.item2 = 0;
+
+        for(i = 0; i < NUM_CONSUMERS; i++) {
+                producer_send(thedata);
+        }
+
+        /* Now wait for all consumers to signal completion. */
+        for(i = 0; i < NUM_CONSUMERS; i++) {
+                P(consumer_finished);
+        }
+
+}
+
+/* The main function for the simulation. */
+int
+run_producerconsumer(int nargs, char **args)
+{
+        (void) nargs; /* Avoid "unused variable" warning */
+        (void) args;
+
+        kprintf("run_producerconsumer: starting up\n");
+
+        /* Initialise synch primitives used in this simulator */
+        consumer_finished = sem_create("consumer_finished", 0);
+        if(!consumer_finished) {
+                panic("run_producerconsumer: couldn't create semaphore\n");
+        }
+
+        producer_finished = sem_create("producer_finished", 0);
+        if(!producer_finished ) {
+                panic("run_producerconsumer: couldn't create semaphore\n");
+        }
+
+        /* Run any code required to initialise synch primitives etc */
+        producerconsumer_startup();
+
+        /* Run the simulation */
+        start_consumer_threads();
+        start_producer_threads();
+
+        /* Wait for all producers and consumers to finish */
+
+        wait_for_producer_threads();
+        stop_consumer_threads();
+
+        /* Run any code required to shut down the simulation */
+        producerconsumer_shutdown();
+
+        /* Done! */
+        sem_destroy(producer_finished);
+        sem_destroy(consumer_finished);
+        return 0;
+}
+
diff --unidirectional-new-file -EdbwBr -u -X /home/cs3231/assigns/asst1/src/../diffex /home/cs3231/assigns/asst1/src/kern/asst1/producer-consumer-tests/producerconsumer_driver3.h /import/ravel/3/z5059988/cs3231/asst1-src/kern/asst1/producer-consumer-tests/producerconsumer_driver3.h
--- kern/asst1/producer-consumer-tests/producerconsumer_driver3.h	1970-01-01 10:00:00.000000000 +1000
+++ kern/asst1/producer-consumer-tests/producerconsumer_driver3.h	2018-03-31 13:43:57.000000000 +1100
@@ -0,0 +1,51 @@
+#ifndef PRODUCERCONSUMER_DRIVER_H
+#define PRODUCERCONSUMER_DRIVER_H
+
+/*  This file contains constants, types, and prototypes for the
+ *  producer consumer problem. It is included by the driver and the
+ *  file you modify so as to share the definitions between both.
+
+ *  YOU SHOULD NOT CHANGE THIS FILE
+
+ *  We will replace it in testing, so any changes will be lost.
+ */
+
+
+#define BUFFER_SIZE 3   /* The size of the bounded buffer */
+
+/*  The buffer must be exactly the size of the constant defined here.
+ *
+ * The producer_send() will block if more than this size is sent to
+ * the buffer, but won't block while there is space in the buffer.
+ */
+
+
+
+/* This is a type definition of the data that you will be passing
+ * around in your own data structures
+ */
+struct pc_data {
+        int item1;
+        int item2;
+};
+
+
+extern int run_producerconsumer(int, char**);
+
+
+
+/* These are the prototypes for the functions you need to write in
+   producerconsumer.c */
+struct pc_data consumer_receive(void); /* receive a data item, blocking
+                                       if no item is available is the
+                                       shared buffer */
+
+void producer_send(struct pc_data); /* send a data item to the shared
+                                       buffer */
+
+void producerconsumer_startup(void); /* initialise your buffer and
+                                        surrounding code */
+
+void producerconsumer_shutdown(void); /* clean up your system at the
+                                         end */
+#endif 
diff --unidirectional-new-file -EdbwBr -u -X /home/cs3231/assigns/asst1/src/../diffex /home/cs3231/assigns/asst1/src/kern/asst1/producer-consumer-tests/producerconsumer_driver4.c /import/ravel/3/z5059988/cs3231/asst1-src/kern/asst1/producer-consumer-tests/producerconsumer_driver4.c
--- kern/asst1/producer-consumer-tests/producerconsumer_driver4.c	1970-01-01 10:00:00.000000000 +1000
+++ kern/asst1/producer-consumer-tests/producerconsumer_driver4.c	2018-03-31 13:43:57.000000000 +1100
@@ -0,0 +1,244 @@
+/*
+ * Driver file for the producer / consumer simulation.
+ *
+ * This starts up a number of producer and consumer threads and has them
+ * communicate via the API defined in producerconsumer_driver.h, which is
+ * implemented by you in producerconsumer.c.
+ *
+ * NOTE: DO NOT RELY ON ANY CHANGES YOU MAKE TO THIS FILE, BECAUSE
+ * IT WILL BE OVERWRITTEN DURING TESTING.
+ */
+#include "opt-synchprobs.h"
+#include <types.h>  /* required by lib.h */
+#include <lib.h>    /* for kprintf */
+#include <synch.h>  /* for P(), V(), sem_* */
+#include <thread.h> /* for thread_fork() */
+#include <test.h>
+
+#include "producerconsumer_driver.h"
+
+/* The number of producers
+ * This will be changed during testing
+ */
+#define NUM_PRODUCERS 9
+
+/* The number of consumer threads
+ * This number will be changed during testing
+ */
+#define NUM_CONSUMERS 11
+
+/* Number of items each producer thread generates before
+ * exiting. This number will be changed during testing.
+ */
+#define ITEMS_TO_PRODUCE 66
+
+/* If a consumer receives more than the following number of
+ * data items, it will automatically exit. This is to help
+ * you during testing. Do not rely on it!
+ */
+#define SOMETHING_WRONG_COUNT 10000
+
+/* Semaphores which the simulator uses to determine when all
+ * producer threads and all consumer threads have finished.
+ */
+static struct semaphore *consumer_finished;
+static struct semaphore *producer_finished;
+
+/* The producer thread's only function. This function calls
+ * producer_send ITEMS_TO_PRODUCE times and then exits. NUM_PRODUCERS
+ * threads are started to run the function.
+ */
+static void
+producer_thread(void *unused_ptr, unsigned long thread_num)
+{
+        struct pc_data thedata;
+        int items_to_go = ITEMS_TO_PRODUCE;
+
+        (void)unused_ptr; /* Avoid compiler warnings */
+
+        kprintf("Producer started\n");
+
+        while(items_to_go > 0) {
+                thedata.item1 = items_to_go + (1000 * thread_num);
+                /* Set second data item as related to the first so that
+                 * the consumer can check both numbers are valid
+                 */
+                thedata.item2 = thedata.item1 + 1;
+
+                producer_send(thedata);
+
+                items_to_go = items_to_go - 1;
+        }
+
+        /* No more items... Signal that we're done. */
+        kprintf("Producer finished\n");
+        V(producer_finished);
+}
+
+/* The consumer thread's only function. NUM_CONSUMERS threads are started,
+ * each of which runs this function. The function continuously calls
+ * consumer_receive() until it receives a special data item containing
+ * two zero integers. NOTE: Don't rely on this specific protocol when designing
+ * your producer_send() and consumer_receive() functions!
+ */
+static void
+consumer_thread(void *unused_ptr, unsigned long thread_num)
+{
+        struct pc_data thedata;
+        int check_count = 0;
+
+        (void)unused_ptr;
+        (void)thread_num;
+
+        kprintf("Consumer started\n");
+
+        thedata = consumer_receive();
+
+        while (thedata.item1 != 0 || thedata.item2 != 0) {
+                if (++check_count >= SOMETHING_WRONG_COUNT) {
+                        /*
+                         * something must be wrong if we received this many
+                         * items.
+                         */
+                        break;
+                }
+
+                /* check we receive sane results */
+                if(thedata.item1 +1 != thedata.item2) {
+                        kprintf("*** Error! Unexpected data %d and %d\n",
+                                thedata.item1, thedata.item2);
+                }
+
+                thedata = consumer_receive();
+        }
+
+        if (check_count >= SOMETHING_WRONG_COUNT) {
+                kprintf("*** Error! Consumer exiting...\n");
+        } else {
+                kprintf("Consumer finished normally\n");
+        }
+
+        /* Signal that we're done. */
+        V(consumer_finished);
+}
+
+/* Create a bunch of threads to consume data. */
+static void
+start_consumer_threads()
+{
+        int i;
+        int result;
+
+        for(i = 0; i < NUM_CONSUMERS; i++) {
+                result = thread_fork("consumer thread", NULL,
+                                     consumer_thread, NULL, i);
+                if(result) {
+                        panic("start_consumer_threads: couldn't fork (%s)\n",
+                              strerror(result));
+                }
+        }
+}
+
+/* Create a bunch of threads to produce data. */
+static void
+start_producer_threads()
+{
+        int i;
+        int result;
+
+        for(i = 0; i < NUM_PRODUCERS; i++) {
+                result = thread_fork("producer thread", NULL,
+                                     producer_thread, NULL, i);
+                if(result) {
+                        panic("start_producer_threads: couldn't fork (%s)\n",
+                              strerror(result));
+                }
+        }
+}
+
+/* Wait for all producer threads to exit.
+ * Producers each produce ITEMS_TO_PRODUCE items and then signal
+ * a semaphore and exit, so waiting for them to finish means
+ * waiting on that semaphore NUM_PRODUCERS times.
+ */
+static void
+wait_for_producer_threads()
+{
+        int i;
+        kprintf("Waiting for producer threads to exit...\n");
+        for(i = 0; i < NUM_PRODUCERS; i++) {
+                P(producer_finished);
+        }
+        kprintf("All producer threads have exited.\n");
+}
+
+/* Instruct all consumer threads to exit and then wait for them
+ * to indicate that they have exited.
+ * Consumer threads run until told to stop using a special
+ * message, described below.
+ */
+static void
+stop_consumer_threads()
+{
+        int i;
+        struct pc_data thedata;
+
+        /* Our protocol for stopping consumer threads is to
+         * enqueue NUM_CONSUMERS sets of 0, 0 data items.
+         * This may change during testing, however.
+         */
+        thedata.item1 = 0;
+        thedata.item2 = 0;
+
+        for(i = 0; i < NUM_CONSUMERS; i++) {
+                producer_send(thedata);
+        }
+
+        /* Now wait for all consumers to signal completion. */
+        for(i = 0; i < NUM_CONSUMERS; i++) {
+                P(consumer_finished);
+        }
+
+}
+
+/* The main function for the simulation. */
+int
+run_producerconsumer(int nargs, char **args)
+{
+        (void) nargs; /* Avoid "unused variable" warning */
+        (void) args;
+
+        kprintf("run_producerconsumer: starting up\n");
+
+        /* Initialise synch primitives used in this simulator */
+        consumer_finished = sem_create("consumer_finished", 0);
+        if(!consumer_finished) {
+                panic("run_producerconsumer: couldn't create semaphore\n");
+        }
+
+        producer_finished = sem_create("producer_finished", 0);
+        if(!producer_finished ) {
+                panic("run_producerconsumer: couldn't create semaphore\n");
+        }
+
+        /* Run any code required to initialise synch primitives etc */
+        producerconsumer_startup();
+
+        /* Run the simulation */
+        start_consumer_threads();
+        start_producer_threads();
+
+        /* Wait for all producers and consumers to finish */
+
+        wait_for_producer_threads();
+        stop_consumer_threads();
+
+        /* Run any code required to shut down the simulation */
+        producerconsumer_shutdown();
+
+        /* Done! */
+        sem_destroy(producer_finished);
+        sem_destroy(consumer_finished);
+        return 0;
+}
+
diff --unidirectional-new-file -EdbwBr -u -X /home/cs3231/assigns/asst1/src/../diffex /home/cs3231/assigns/asst1/src/kern/asst1/producer-consumer-tests/producerconsumer_driver5.c /import/ravel/3/z5059988/cs3231/asst1-src/kern/asst1/producer-consumer-tests/producerconsumer_driver5.c
--- kern/asst1/producer-consumer-tests/producerconsumer_driver5.c	1970-01-01 10:00:00.000000000 +1000
+++ kern/asst1/producer-consumer-tests/producerconsumer_driver5.c	2018-03-31 13:43:57.000000000 +1100
@@ -0,0 +1,244 @@
+/*
+ * Driver file for the producer / consumer simulation.
+ *
+ * This starts up a number of producer and consumer threads and has them
+ * communicate via the API defined in producerconsumer_driver.h, which is
+ * implemented by you in producerconsumer.c.
+ *
+ * NOTE: DO NOT RELY ON ANY CHANGES YOU MAKE TO THIS FILE, BECAUSE
+ * IT WILL BE OVERWRITTEN DURING TESTING.
+ */
+#include "opt-synchprobs.h"
+#include <types.h>  /* required by lib.h */
+#include <lib.h>    /* for kprintf */
+#include <synch.h>  /* for P(), V(), sem_* */
+#include <thread.h> /* for thread_fork() */
+#include <test.h>
+
+#include "producerconsumer_driver.h"
+
+/* The number of producers
+ * This will be changed during testing
+ */
+#define NUM_PRODUCERS 3
+
+/* The number of consumer threads
+ * This number will be changed during testing
+ */
+#define NUM_CONSUMERS 3
+
+/* Number of items each producer thread generates before
+ * exiting. This number will be changed during testing.
+ */
+#define ITEMS_TO_PRODUCE 16
+
+/* If a consumer receives more than the following number of
+ * data items, it will automatically exit. This is to help
+ * you during testing. Do not rely on it!
+ */
+#define SOMETHING_WRONG_COUNT 10000
+
+/* Semaphores which the simulator uses to determine when all
+ * producer threads and all consumer threads have finished.
+ */
+static struct semaphore *consumer_finished;
+static struct semaphore *producer_finished;
+
+/* The producer thread's only function. This function calls
+ * producer_send ITEMS_TO_PRODUCE times and then exits. NUM_PRODUCERS
+ * threads are started to run the function.
+ */
+static void
+producer_thread(void *unused_ptr, unsigned long thread_num)
+{
+        struct pc_data thedata;
+        int items_to_go = ITEMS_TO_PRODUCE;
+
+        (void)unused_ptr; /* Avoid compiler warnings */
+
+        kprintf("Producer started\n");
+
+        while(items_to_go > 0) {
+                thedata.item1 = items_to_go + (1000 * thread_num);
+                /* Set second data item as related to the first so that
+                 * the consumer can check both numbers are valid
+                 */
+                thedata.item2 = thedata.item1 + 1;
+
+                producer_send(thedata);
+
+                items_to_go = items_to_go - 1;
+        }
+
+        /* No more items... Signal that we're done. */
+        kprintf("Producer finished\n");
+        V(producer_finished);
+}
+
+/* The consumer thread's only function. NUM_CONSUMERS threads are started,
+ * each of which runs this function. The function continuously calls
+ * consumer_receive() until it receives a special data item containing
+ * two zero integers. NOTE: Don't rely on this specific protocol when designing
+ * your producer_send() and consumer_receive() functions!
+ */
+static void
+consumer_thread(void *unused_ptr, unsigned long thread_num)
+{
+        struct pc_data thedata;
+        int check_count = 0;
+
+        (void)unused_ptr;
+        (void)thread_num;
+
+        kprintf("Consumer started\n");
+
+        thedata = consumer_receive();
+
+        while (thedata.item1 != 0 || thedata.item2 != 0) {
+                if (++check_count >= SOMETHING_WRONG_COUNT) {
+                        /*
+                         * something must be wrong if we received this many
+                         * items.
+                         */
+                        break;
+                }
+
+                /* check we receive sane results */
+                if(thedata.item1 +1 != thedata.item2) {
+                        kprintf("*** Error! Unexpected data %d and %d\n",
+                                thedata.item1, thedata.item2);
+                }
+
+                thedata = consumer_receive();
+        }
+
+        if (check_count >= SOMETHING_WRONG_COUNT) {
+                kprintf("*** Error! Consumer exiting...\n");
+        } else {
+                kprintf("Consumer finished normally\n");
+        }
+
+        /* Signal that we're done. */
+        V(consumer_finished);
+}
+
+/* Create a bunch of threads to consume data. */
+static void
+start_consumer_threads()
+{
+        int i;
+        int result;
+
+        for(i = 0; i < NUM_CONSUMERS; i++) {
+                result = thread_fork("consumer thread", NULL,
+                                     consumer_thread, NULL, i);
+                if(result) {
+                        panic("start_consumer_threads: couldn't fork (%s)\n",
+                              strerror(result));
+                }
+        }
+}
+
+/* Create a bunch of threads to produce data. */
+static void
+start_producer_threads()
+{
+        int i;
+        int result;
+
+        for(i = 0; i < NUM_PRODUCERS; i++) {
+                result = thread_fork("producer thread", NULL,
+                                     producer_thread, NULL, i);
+                if(result) {
+                        panic("start_producer_threads: couldn't fork (%s)\n",
+                              strerror(result));
+                }
+        }
+}
+
+/* Wait for all producer threads to exit.
+ * Producers each produce ITEMS_TO_PRODUCE items and then signal
+ * a semaphore and exit, so waiting for them to finish means
+ * waiting on that semaphore NUM_PRODUCERS times.
+ */
+static void
+wait_for_producer_threads()
+{
+        int i;
+        kprintf("Waiting for producer threads to exit...\n");
+        for(i = 0; i < NUM_PRODUCERS; i++) {
+                P(producer_finished);
+        }
+        kprintf("All producer threads have exited.\n");
+}
+
+/* Instruct all consumer threads to exit and then wait for them
+ * to indicate that they have exited.
+ * Consumer threads run until told to stop using a special
+ * message, described below.
+ */
+static void
+stop_consumer_threads()
+{
+        int i;
+        struct pc_data thedata;
+
+        /* Our protocol for stopping consumer threads is to
+         * enqueue NUM_CONSUMERS sets of 0, 0 data items.
+         * This may change during testing, however.
+         */
+        thedata.item1 = 0;
+        thedata.item2 = 0;
+
+        for(i = 0; i < NUM_CONSUMERS; i++) {
+                producer_send(thedata);
+        }
+
+        /* Now wait for all consumers to signal completion. */
+        for(i = 0; i < NUM_CONSUMERS; i++) {
+                P(consumer_finished);
+        }
+
+}
+
+/* The main function for the simulation. */
+int
+run_producerconsumer(int nargs, char **args)
+{
+        (void) nargs; /* Avoid "unused variable" warning */
+        (void) args;
+
+        kprintf("run_producerconsumer: starting up\n");
+
+        /* Initialise synch primitives used in this simulator */
+        consumer_finished = sem_create("consumer_finished", 0);
+        if(!consumer_finished) {
+                panic("run_producerconsumer: couldn't create semaphore\n");
+        }
+
+        producer_finished = sem_create("producer_finished", 0);
+        if(!producer_finished ) {
+                panic("run_producerconsumer: couldn't create semaphore\n");
+        }
+
+        /* Run any code required to initialise synch primitives etc */
+        producerconsumer_startup();
+
+        /* Run the simulation */
+        start_consumer_threads();
+        start_producer_threads();
+
+        /* Wait for all producers and consumers to finish */
+
+        wait_for_producer_threads();
+        stop_consumer_threads();
+
+        /* Run any code required to shut down the simulation */
+        producerconsumer_shutdown();
+
+        /* Done! */
+        sem_destroy(producer_finished);
+        sem_destroy(consumer_finished);
+        return 0;
+}
+
diff --unidirectional-new-file -EdbwBr -u -X /home/cs3231/assigns/asst1/src/../diffex /home/cs3231/assigns/asst1/src/kern/asst1/producerconsumer.c /import/ravel/3/z5059988/cs3231/asst1-src/kern/asst1/producerconsumer.c
--- kern/asst1/producerconsumer.c	2018-03-09 13:16:22.000000000 +1100
+++ kern/asst1/producerconsumer.c	2018-03-31 13:43:57.000000000 +1100
@@ -1,51 +1,83 @@
-/* This file will contain your solution. Modify it as you wish. */
 #include <types.h>
-#include "producerconsumer_driver.h"
-
-/* Declare any variables you need here to keep track of and
-   synchronise your bounded. A sample declaration of a buffer is shown
-   below. You can change this if you choose another implementation. */
+#include <synch.h>
+#include <lib.h>
 
-static struct pc_data buffer[BUFFER_SIZE];
+#include "producerconsumer_driver.h"
 
+/* bounded buffer for the producer/consumer */
+static struct _buffer {
+	struct pc_data data[BUFFER_SIZE];
+	uint32_t head, tail; /* tail is next available slot */
+	uint32_t num_items;
+} buffer;
 
-/* consumer_receive() is called by a consumer to request more data. It
-   should block on a sync primitive if no data is available in your
-   buffer. */
+/* synchronization primitives for the producer/consumer */
+static struct cv *has_capacity;
+static struct cv *has_data;
+static struct lock *buffer_lock;
 
-struct pc_data consumer_receive(void)
-{
-        struct pc_data thedata;
+/*
+ * consumer_receive() is called by a consumer to request more data. It
+ * should block on a sync primitive if no data is available in your
+ * buffer.
+ */
+struct pc_data consumer_receive(void) {
+	lock_acquire(buffer_lock);
+	while (buffer.num_items == 0)
+		cv_wait(has_data, buffer_lock);
 
-        (void) buffer; /* remove this line when you start */
+	struct pc_data thedata = buffer.data[buffer.head++];
+	buffer.head %= BUFFER_SIZE;
+	buffer.num_items--;
 
-        /* FIXME: this data should come from your buffer, obviously... */
-        thedata.item1 = 1;
-        thedata.item2 = 2;
+	cv_signal(has_capacity, buffer_lock);
+	lock_release(buffer_lock);
 
         return thedata;
 }
 
-/* procucer_send() is called by a producer to store data in your
-   bounded buffer. */
-
-void producer_send(struct pc_data item)
-{
-        (void) item; /* Remove this when you add your code */
-}
+/*
+ * procucer_send() is called by a producer to store data in your
+ * bounded buffer.
+ */
+void producer_send(struct pc_data item) {
+	lock_acquire(buffer_lock);
+	while (buffer.num_items == BUFFER_SIZE)
+		cv_wait(has_capacity, buffer_lock);
 
+	buffer.data[buffer.tail++] = item;
+	buffer.tail %= BUFFER_SIZE;
+	buffer.num_items++;
 
+	cv_signal(has_data, buffer_lock);
+	lock_release(buffer_lock);
+}
 
+/*
+ * Perform any initialisation (e.g. of global data) you need
+ * here. Note: You can panic if any allocation fails during setup
+ */
+void producerconsumer_startup(void) {
+	has_capacity = cv_create("has capacity");
+	has_data = cv_create("has data");
+	buffer_lock = lock_create("buffer lock");
 
-/* Perform any initialisation (e.g. of global data) you need
-   here. Note: You can panic if any allocation fails during setup */
+	if (has_capacity == NULL)
+		panic("%s: has_capacity create failed", __FILE__);
+	if (has_data == NULL)
+		panic("%s: has_data create failed", __FILE__);
+	if (buffer_lock == NULL)
+		panic("%s: buffer_lock create failed", __FILE__);
 
-void producerconsumer_startup(void)
-{
+	/* initialise buffer props */
+	buffer.head = 0;
+	buffer.tail = 0;
+	buffer.num_items = 0;
 }
 
 /* Perform any clean-up you need here */
-void producerconsumer_shutdown(void)
-{
+void producerconsumer_shutdown(void) {
+	cv_destroy(has_capacity);
+	cv_destroy(has_data);
+	lock_destroy(buffer_lock);
 }
-
diff --unidirectional-new-file -EdbwBr -u -X /home/cs3231/assigns/asst1/src/../diffex /home/cs3231/assigns/asst1/src/kern/asst1/quicksort.c /import/ravel/3/z5059988/cs3231/asst1-src/kern/asst1/quicksort.c
--- kern/asst1/quicksort.c	1970-01-01 10:00:00.000000000 +1000
+++ kern/asst1/quicksort.c	2018-03-28 11:37:16.000000000 +1100
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2017 Costa Paraskevopoulos.
+ * Copyright (C) 2017 Dominic Fung.
+ * Uses the quicksort algorithm to sort an array of integers.
+ * Derived from https://en.wikipedia.org/wiki/Quicksort.
+ */
+
+#include "quicksort.h"
+
+static void partition(unsigned int a[], int l, int r, int *p);
+static void swap(unsigned int a[], int i, int j);
+
+//sorts an array between the indexes l and r
+void quicksort(unsigned int a[], int l, int r) {
+	if (l < r) {
+		int p;
+		partition(a, l, r, &p);
+		quicksort(a, l, p - 1);
+		quicksort(a, p + 1, r);
+	}
+}
+
+//partitions an array around a pivot value
+//returns the index of the pivot value
+static void partition(unsigned int a[], int l, int r, int *p) {
+	unsigned int pivot = a[r]; //rightmost is pivot
+	int i = l - 1;
+
+	//arrange a to [(<=pivot)(pivot)(=>pivot)]
+	int j = l;
+	while (j != r) {
+		if (a[j] <= pivot) {
+			i = i + 1;
+			swap(a, i, j);
+		}
+		j = j + 1;
+	}
+	swap(a, i + 1, r); //move pivot to the "middle"
+
+	*p = i + 1;
+}
+
+//swaps two elements of an array at the given indexes
+static void swap(unsigned int a[], int i, int j) {
+	unsigned int temp = a[i];
+	a[i] = a[j];
+	a[j] = temp;
+}
diff --unidirectional-new-file -EdbwBr -u -X /home/cs3231/assigns/asst1/src/../diffex /home/cs3231/assigns/asst1/src/kern/asst1/quicksort.h /import/ravel/3/z5059988/cs3231/asst1-src/kern/asst1/quicksort.h
--- kern/asst1/quicksort.h	1970-01-01 10:00:00.000000000 +1000
+++ kern/asst1/quicksort.h	2018-03-28 11:48:09.000000000 +1100
@@ -0,0 +1,9 @@
+#ifndef QUICKSORT_H
+#define QUICKSORT_H
+
+/*
+ * Sort a[l..r] using quicksort
+ */
+void quicksort(unsigned int a[], int l, int r);
+
+#endif
diff --unidirectional-new-file -EdbwBr -u -X /home/cs3231/assigns/asst1/src/../diffex /home/cs3231/assigns/asst1/src/kern/asst1/run_tests.sh /import/ravel/3/z5059988/cs3231/asst1-src/kern/asst1/run_tests.sh
--- kern/asst1/run_tests.sh	1970-01-01 10:00:00.000000000 +1000
+++ kern/asst1/run_tests.sh	2018-03-31 13:55:43.541921632 +1100
@@ -0,0 +1,59 @@
+#!/bin/sh
+
+if test "$#" -ne 1
+then
+	echo "Usage: $0 (pc-prob|bar-prob)" >&2
+	exit 1
+fi
+
+original_c=`mktemp -p /tmp`
+original_h=`mktemp -p /tmp`
+original_h2=`mktemp -p /tmp`
+
+if test "$1" = pc-prob
+then
+	#run tests for producer-consumer problem
+	mv producerconsumer_driver.c $original_c
+	mv producerconsumer_driver.h $original_h
+	for h in producer-consumer-tests/*.h
+	do
+		cp "$h" producerconsumer_driver.h
+		for c in producer-consumer-tests/*.c
+		do
+			cp "$c" producerconsumer_driver.c
+			make && make run args='1c;q'
+		done
+	done
+	mv $original_c producerconsumer_driver.c
+	mv $original_h producerconsumer_driver.h
+elif test "$1" = bar-prob
+then
+	#run tests for bar sync problem
+	mv bar_driver.c $original_c
+	cp bar_driver.h $original_h
+	cp barglass.h $original_h2
+	cp bar-tests/bar_driver.c .
+	for cust in 1 3 10 32
+	do
+		for bart in 1 3 10 32
+		do
+			for drink in 1 3 5 8
+			do
+				for bottle in 1 3 10 16
+				do
+					sed -i "s/NCUSTOMERS [0-9]*/NCUSTOMERS $cust/" bar_driver.h
+					sed -i "s/NBARTENDERS [0-9]*/NBARTENDERS $bart/" bar_driver.h
+					sed -i "s/NBOTTLES [0-9]*/NBOTTLES $drink/" barglass.h
+					sed -i "s/DRINK_COMPLEXITY [0-9]*/DRINK_COMPLEXITY $bottle/" barglass.h
+					make && make run args='1d;q'
+				done
+			done
+		done
+	done
+	mv $original_c bar_driver.c
+	mv $original_h bar_driver.h
+	mv $original_h2 barglass.h
+else
+	echo "$0: unknown test '$1'" >&2
+	exit 1
+fi
diff --unidirectional-new-file -EdbwBr -u -X /home/cs3231/assigns/asst1/src/../diffex /home/cs3231/assigns/asst1/src/kern/asst1/twolocks.c /import/ravel/3/z5059988/cs3231/asst1-src/kern/asst1/twolocks.c
--- kern/asst1/twolocks.c	2018-03-09 13:16:22.000000000 +1100
+++ kern/asst1/twolocks.c	2018-03-28 11:37:16.000000000 +1100
@@ -16,12 +13,9 @@
 /* a constant indicating how many times the locking loops go round */
 #define NUM_LOOPS 1000
 
-
 /* Bill and Ben are two threads that simply spin for a while,
    acquiring and releasing locks */
-
-static void bill(void * unusedpointer, unsigned long unusedint)
-{
+static void bill(void *unusedpointer, unsigned long unusedint) {
         int i;
         kprintf("Hi, I'm Bill\n");
 
@@ -44,17 +38,13 @@
                         finished */
 }
 
-
-
-static void ben(void * unusedpointer, unsigned long unusedint)
-{
-
+static void ben(void *unusedpointer, unsigned long unusedint) {
         int i;
         kprintf("Hi, I'm Ben\n");
 
         for (i = 0; i < NUM_LOOPS; i++) {
-                lock_acquire(lockb);
                 lock_acquire(locka);
+                lock_acquire(lockb);
 
                 /* Ben now holds both locks and can do what ever bill
                    needs to do while holding the locks (nothing in
@@ -69,11 +59,9 @@
         kprintf("Ben says 'bye'\n");
         V(finished); /* indicate to the parent thread Bill has
                         finished */
-
 }
 
-int twolocks (int data1, char ** data2)
-{
+int twolocks(int data1, char **data2) {
         int error;
         /*
          * Avoid unused variable warnings.
Only in /home/cs3231/assigns/asst1/src/kern/compile: .keep_me
diff --unidirectional-new-file -EdbwBr -u -X /home/cs3231/assigns/asst1/src/../diffex /home/cs3231/assigns/asst1/src/kern/conf/conf.kern /import/ravel/3/z5059988/cs3231/asst1-src/kern/conf/conf.kern
--- kern/conf/conf.kern	2018-03-09 13:16:22.000000000 +1100
+++ kern/conf/conf.kern	2018-03-28 11:37:16.000000000 +1100
@@ -438,6 +438,9 @@
 optfile   synchprobs  asst1/producerconsumer_driver.c
 optfile   synchprobs  asst1/bar.c
 optfile   synchprobs  asst1/bar_driver.c
+optfile   synchprobs  asst1/Queue.c
+optfile   synchprobs  asst1/quicksort.c
+
 
 
 
diff --unidirectional-new-file -EdbwBr -u -X /home/cs3231/assigns/asst1/src/../diffex /home/cs3231/assigns/asst1/src/kern/main/main.c /import/ravel/3/z5059988/cs3231/asst1-src/kern/main/main.c
--- kern/main/main.c	2018-03-09 13:16:22.000000000 +1100
+++ kern/main/main.c	2018-03-31 13:43:57.000000000 +1100
@@ -102,7 +102,7 @@
 	kprintf("%s", harvard_copyright);
 	kprintf("\n");
 
-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n",
+	kprintf("osprj175's system version %s (%s #%d)\n",
 		GROUP_VERSION, buildconfig, buildversion);
 	kprintf("\n");
 
